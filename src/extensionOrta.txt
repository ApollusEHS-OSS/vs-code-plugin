import * as vscode from 'vscode';
import { fileURLToPath } from 'url';
import * as path from 'path';
import * as fs from 'fs';
import * as ps from 'ps-node';
import * as child_process from 'child_process';
import * as events from 'events';
import * as os from 'os';

const aesopEmitter = new events.EventEmitter();

import { Channel, ChannelHandler } from '@storybook/channels';
import createChannel from "@storybook/channel-websocket"
import * as WebSocket from 'ws';
import { TreeViewProvider, StoryObject, Story } from "./treeviewProvider"
import { QuickPickProvider, StorySelection } from "./quickpickProvider"

const g = global as any;
g.WebSocket = WebSocket;
let storybooksChannel: any;
let establishedConnection : boolean = false;


export function activate(context: vscode.ExtensionContext) {
  

	class WebviewHTMLProvider implements vscode.TextDocumentContentProvider {
		public provideTextDocumentContent(uri: vscode.Uri): string {
			//do we need to pass these arguments to the webviewprovider from our processes?
			//https://code.visualstudio.com/api/references/vscode-api#WorkspaceConfiguration
			//UPDATE configuration when found

			//'PORT' and 'host' have defaults configured manually in the package.json
			const port = vscode.workspace.getConfiguration("aesop").get("port")
			const host = vscode.workspace.getConfiguration("aesop").get("host")

			//this return value is what would normally get popped into the preview --> /?path=/story/${storyUri}
			return `
			<!DOCTYPE html>
			<html lang="en">
				<head>
					<meta charset="UTF-8">
					<meta name="viewport" content="width=device-width, initial-scale=1.0">
					<title>Aesop</title>
					<style>
					iframe {
						position: fixed;
						border: none;
						padding: 0;
						margins: 0;
						width: 100%;
						height: 100%;
					}
				</style>
				</head>
				<body>
					<iframe src="http://${host}:${port}></iframe>
				</body>
			</html>`
		}
	}

	let provider = new WebviewHTMLProvider();
	let webviewHTMLRegistration = vscode.workspace.registerTextDocumentContentProvider("storybook", provider);















  vscode.commands.registerCommand("extension.searchStories", () => {
    vscode.window.showQuickPick(pickerProvider.toList()).then((picked: string) => {
      const setParams = pickerProvider.getParts(picked)
      setCurrentStory(setParams)
    })
  })

  // Allow clicking, and keep state on what is selected
  vscode.commands.registerCommand("extension.openStory", (section, story) => {
    // Handle a Double click
    if (currentStoryId === story.id && currentKind === section.kind && currentStory === story.name) {
      findFileForStory(section.kind, story.name).then(results => {
        if (results) {
          vscode.workspace.openTextDocument(results.uri).then(doc => {
            vscode.window.showTextDocument(doc).then(shownDoc => {
              let range = doc.lineAt(results.line - 1).range
              vscode.window.activeTextEditor.selection = new vscode.Selection(range.start, range.end)
              vscode.window.activeTextEditor.revealRange(range, vscode.TextEditorRevealType.InCenter)
            })
          })
        }
      })
      return
    }

    setCurrentStory({ storyId: story.id, kind: section.kind, story: story.name })
  })

  function setCurrentStory(params: StorySelection) {
    const currentChannel = () => storybooksChannel
    currentKind = params.kind
    currentStory = params.story
    currentStoryId = params.storyId
    currentChannel().emit("setCurrentStory", params)
  }

  vscode.commands.registerCommand("extension.goToNextStorybook", () => {
    const stories = storyTreeViewProvider.stories
    const currentSection = stories.find(s => s.kind === currentKind)
    const currentStories = currentSection.stories
    const currentIndex = currentStories.map(e => e.id).indexOf(currentStoryId)
    if (currentIndex === currentStories.length) {
      // if you have reached the last story of an array of stories, enables the ability to wrap around
      vscode.commands.executeCommand("extension.openStory", currentSection, currentStories[0])
    } else {

      vscode.commands.executeCommand("extension.openStory", currentSection, currentStories[currentIndex + 1])
    }
  })

  vscode.commands.registerCommand("extension.goToPreviousStorybook", () => {
    const stories = storyTreeViewProvider.stories
    const currentSection = stories.find(s => s.kind === currentKind)
    const currentStories = currentSection.stories
    const currentIndex = currentStories.map(e => e.id).indexOf(currentStoryId)
    if (currentIndex === 0) {
      // if you have reached the last story of an array of stories, enables the ability to wrap around
      vscode.commands.executeCommand("extension.openStory", currentSection, currentStories[currentStories.length - 1])
    } else {
      vscode.commands.executeCommand("extension.openStory", currentSection, currentStories[currentIndex - 1])
    }
  })

  // Loop through all globbed stories,
	// reading the files for the kind and the story name
  
	const findFileForStory = async (kind: string, story: string): Promise<{ uri: vscode.Uri; line: number } | null> => {
		return new Promise<{ uri: vscode.Uri; line: number }>((resolve, reject) => {
			//this regex is set as a glob expression in package.json that finds **.story.* files
			const regex = vscode.workspace.getConfiguration("react-native-storybooks").get("storyRegex") as string

			const root = vscode.workspace.workspaceFolders
			vscode.workspace.findFiles(regex, "**/node_modules").then(files => {
				let found = false
				for (const file of files) {
					const content = fs.readFileSync(file.fsPath, "utf8")
					if (content.includes(kind) && content.includes(story)) {
						const line = content.split(story)[0].split("\n").length
						resolve({ uri: file, line })
						found = true
					}
				}
				if (!found) {
					resolve(null)
				}
			})
		})
  }
}

export function deactivate(){
  // storybooksChannel.transport.socket.close()
}
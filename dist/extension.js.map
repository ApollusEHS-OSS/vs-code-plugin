{"version":3,"sources":["../webpack/bootstrap",".././node_modules/connected-domain/index.js",".././node_modules/connected-domain/lib/connected-domain.js",".././node_modules/ps-node/index.js",".././node_modules/ps-node/lib/index.js",".././node_modules/table-parser/index.js",".././node_modules/table-parser/lib/index.js",".././src/extension.ts","../external \"child_process\"","../external \"fs\"","../external \"os\"","../external \"path\"","../external \"url\"","../external \"vscode\""],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,iBAAiB,mBAAO,EAAE,uFAAwB,G;;;;;;;;;;;ACAlD;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,YAAY,OAAO,GAAG,YAAY,2BAA2B,aAAa,sBAAsB,EAAE,qCAAqC;AACvI;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;AC/PA,iBAAiB,mBAAO,CAAC,kDAAO;;;;;;;;;;;;ACAhC,mBAAmB,mBAAO,CAAC,oCAAe;AAC1C;AACA,kBAAkB,mBAAO,CAAC,0DAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,cAAI;;AAE5B;AACA;AACA,UAAU;AACV,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,WAAW;AAC/B;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;ACpSA,iBAAiB,mBAAO,EAAE,6DAAa,G;;;;;;;;;;;ACAvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAO,CAAC,kEAAkB;AAChD;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","file":"extension.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/extension.ts\");\n","module.exports = require( './lib/connected-domain' );","/**\n * calculate all the connected domains based on the given two-dimensional array\n */\n\n/**\n * @param {Array} tdArray\n * @param {Function} indicator It receive the raw point data as the first parameter and decide what kind of domain the point belongs to, it should return a string as a domain identifier.\n * @param {Boolean} hardlink If use hard link. Default to false.\n * @return {Object} [{ bounding: { w: 12, h: 19, x: 0, y: 1 }, points: [ { x: 1, y: 2, point: {} } ], identifier: 'blue', domainId: 1 } ]\n */\nmodule.exports = function( tdArray, indicator, hardlink ){\n\n    hardlink = hardlink || false;\n\n    if( !tdArray ){\n        throw new Error( 'tdArray must be provided' );\n    }\n\n    if( !indicator ){\n        throw new Error( 'indicator must be provided' );\n    }\n\n    // clone 一份数据，因为需要对饮用进行修改，方便执行\n    tdArray = JSON.parse( JSON.stringify( tdArray ) );\n\n    // Result\n    var domains = {};\n    var domainUUID = 0;\n    var pointsHash = {};\n\n    // 遍历数组，划分domain\n\n    tdArray.forEach(function( row, y ){\n\n        row.forEach(function( colItem, x ){\n\n            // get the current point identifier.\n            var identifier = indicator( colItem, x, y );\n\n            // get neighbours\n            // Except for Undefined every data type is valid.\n            var neighbours = [];\n\n            // top neighbour\n            if( tdArray[ y - 1 ] && tdArray[ y - 1 ][ x ] !== undefined ){\n                neighbours.push( pointsHash[ x + '_' + ( y - 1 ) ] );\n            }\n\n            // left neighbour\n            if( row[ x - 1 ] !== undefined ){\n                neighbours.push( pointsHash[ ( x - 1 ) + '_' + y ] );\n            }\n\n            // soft link will treat corner link as domain link.\n            if( !hardlink ){\n                // top left neighbour\n                if( tdArray[ y - 1 ] && tdArray[ y - 1 ][ x - 1 ] !== undefined ){\n                    neighbours.push( pointsHash[ ( x - 1 ) + '_' + ( y - 1 ) ] );\n                }\n\n                // top right neighbour\n                if( tdArray[ y - 1 ] && tdArray[ y - 1 ][ x + 1 ] !== undefined ){\n                    neighbours.push( pointsHash[ ( x + 1 ) + '_' + ( y - 1 ) ] );\n                }\n            }\n\n            if( neighbours.length ){\n                var matched = false;\n\n                neighbours.forEach(function( neighbour ){\n\n                    if( neighbour.identifier == identifier ){\n\n                        // If the neighbour is the first neighbour has the same identifier\n                        if( !matched ){\n                            addPointToDomain( colItem, x, y, neighbour.domainId );\n                            matched = true;\n                        }\n\n                        // If more than one neighbour matched, check if these neighbours belong to the same domain\n                        // If not, merge these domains since they connects to each other.\n                        else {\n                            var colItemPoint = pointsHash[ x + '_' + y ];\n                            if( neighbour.domainId != colItemPoint.domainId ){\n                                mergeDomains( neighbour.domainId, colItemPoint.domainId );\n                            }\n                        }\n                    }\n                });\n\n                if( !matched ){\n                    addNewDomain( colItem, x, y, identifier );\n                }\n            }\n            else {\n                addNewDomain( colItem, x, y, identifier );\n            }\n        });\n    });\n\n    // some summary\n    var result = {\n        domains: [],\n        totalDomains: 0,\n        groupByIdentifier: {},\n        totalIdentifiers: 0\n    };\n\n    var domainId = null;\n    var identifier = null;\n    var domain = null;\n    for( domainId in domains ){\n        domain = domains[ domainId ];\n        domain.bounding = calculateBounding( domain.points );\n        identifier = domain.identifier;\n\n        result.domains.push( domain );\n        result.totalDomains++;\n\n        if( !( identifier in result.groupByIdentifier ) ){\n            result.groupByIdentifier[ identifier ] = [];\n            result.totalIdentifiers++;\n        }\n\n        result.groupByIdentifier[ identifier ].push( domain );\n    }\n\n\n    function calculateBounding( points ){\n\n        var minX = null;\n        var minY = null;\n        var maxX = null;\n        var maxY = null;\n\n        points.forEach(function( point ){\n\n            if( minX === null || point.x < minX ){\n                minX = point.x;\n            }\n\n            if( minY === null || point.y < minY ){\n                minY = point.y;\n            }\n\n            if( maxX === null || point.x > maxX ){\n                maxX = point.x;\n            }\n\n            if( maxY === null || point.y > maxY ){\n                maxY = point.y;\n            }\n        });\n\n        var w = maxX - minX;\n        var h = maxY - minY;\n\n        return {\n            x: minX,\n            y: minY,\n            w: w,\n            h: h\n        };\n    }\n\n    /**\n     *\n     * @param point\n     * @param x\n     * @param y\n     * @param identifier\n     */\n    function addNewDomain( point, x, y, identifier ){\n\n        var newDomain = {\n            identifier: identifier,\n            domainId: ++domainUUID,\n            bounding: {},\n            points: []\n        };\n\n        var newPoint = {\n            value: point,\n            x: x,\n            y: y,\n            identifier: identifier,\n            domainId: newDomain.domainId\n        };\n\n        pointsHash[ x + '_' + y ] = {\n            value: point,\n            identifier: identifier,\n            domainId: newDomain.domainId\n        };\n\n        newDomain.points.push( newPoint );\n\n        domains[ newDomain.domainId ] = newDomain;\n    }\n\n    /**\n     * add a point to a existing domain, and attach properties domainId and identifier to point.\n     * @param point\n     * @param x\n     * @param y\n     * @param domainId\n     */\n    function addPointToDomain( point, x, y, domainId ){\n\n        var domain = domains[ domainId ];\n        var newPoint = {\n            value: point,\n            x: x,\n            y: y,\n            identifier: domain.identifier,\n            domainId: domainId\n        };\n\n        pointsHash[ x + '_' + y ] = {\n            value: point,\n            identifier: domain.identifier,\n            domainId: domainId\n        };\n\n        domain.points.push( newPoint );\n    }\n\n    /**\n     * 将 domainB 合并到 domainA\n     * @param domainAId\n     * @param domainBId\n     */\n    function mergeDomains( domainAId, domainBId ){\n\n        var domainA = domains[ domainAId ];\n        var domainB = domains[ domainBId ];\n\n        if( domainA.identifier == domainB.identifier ){\n            // 更新 domainB 的domainId\n\n            domainB.domainId = domainA.domainId;\n\n            domainB.points.forEach(function( point ){\n                point.domainId = domainA.domainId;\n                pointsHash[ point.x + '_' + point.y ].domainId = domainA.domainId;\n            });\n\n            domainA.points = domainA.points.concat( domainB.points );\n\n            // 删除domainB\n            delete domains[ domainBId ];\n        }\n    }\n\n    return result;\n};","module.exports = require('./lib');\n","var ChildProcess = require('child_process');\nvar IS_WIN = process.platform === 'win32';\nvar TableParser = require('table-parser');\n/**\n * End of line.\n * Basically, the EOL should be:\n * - windows: \\r\\n\n * - *nix: \\n\n * But i'm trying to get every possibilities covered.\n */\nvar EOL = /(\\r\\n)|(\\n\\r)|\\n|\\r/;\nvar SystemEOL = require('os').EOL;\n\n/**\n * Execute child process\n * @type {Function}\n * @param {String[]} args\n * @param {Function} callback\n * @param {Object=null} callback.err\n * @param {Object[]} callback.stdout\n */\n\nvar Exec = module.exports = exports = function (args, callback) {\n  var spawn = ChildProcess.spawn;\n\n  // on windows, if use ChildProcess.exec(`wmic process get`), the stdout will gives you nothing\n  // that's why I use `cmd` instead\n  if (IS_WIN) {\n\n    var CMD = spawn('cmd');\n    var stdout = '';\n    var stderr = null;\n\n    CMD.stdout.on('data', function (data) {\n      stdout += data.toString();\n    });\n\n    CMD.stderr.on('data', function (data) {\n\n      if (stderr === null) {\n        stderr = data.toString();\n      }\n      else {\n        stderr += data.toString();\n      }\n    });\n\n    CMD.on('exit', function () {\n\n      var beginRow;\n      stdout = stdout.split(EOL);\n\n      // Find the line index for the titles\n      stdout.forEach(function (out, index) {\n        if (out && typeof beginRow == 'undefined' && out.indexOf('CommandLine') === 0) {\n          beginRow = index;\n        }\n      });\n\n      // get rid of the start (copyright) and the end (current pwd)\n      stdout.splice(stdout.length - 1, 1);\n      stdout.splice(0, beginRow);\n\n      callback(stderr, stdout.join(SystemEOL) || false);\n    });\n\n    CMD.stdin.write('wmic process get ProcessId,ParentProcessId,CommandLine \\n');\n    CMD.stdin.end();\n  }\n  else {\n    if (typeof args === 'string') {\n      args = args.split(/\\s+/);\n    }\n    const child = spawn('ps', args);\n    var stdout = '';\n    var stderr = null;\n\n    child.stdout.on('data', function (data) {\n      stdout += data.toString();\n    });\n\n    child.stderr.on('data', function (data) {\n\n      if (stderr === null) {\n        stderr = data.toString();\n      }\n      else {\n        stderr += data.toString();\n      }\n    });\n\n    child.on('exit', function () {\n      if (stderr) {\n        return callback(stderr.toString());\n      }\n      else {\n        callback(null, stdout || false);\n      }\n    });\n  }\n};\n\n/**\n * Query Process: Focus on pid & cmd\n * @param query\n * @param {String|String[]} query.pid\n * @param {String} query.command RegExp String\n * @param {String} query.arguments RegExp String\n * @param {String|array} query.psargs\n * @param {Function} callback\n * @param {Object=null} callback.err\n * @param {Object[]} callback.processList\n * @return {Object}\n */\n\nexports.lookup = function (query, callback) {\n\n  /**\n   * add 'lx' as default ps arguments, since the default ps output in linux like \"ubuntu\", wont include command arguments\n   */\n  var exeArgs = query.psargs || ['lx'];\n  var filter = {};\n  var idList;\n\n  // Lookup by PID\n  if (query.pid) {\n\n    if (Array.isArray(query.pid)) {\n      idList = query.pid;\n    }\n    else {\n      idList = [query.pid];\n    }\n\n    // Cast all PIDs as Strings\n    idList = idList.map(function (v) {\n      return String(v);\n    });\n\n  }\n\n\n  if (query.command) {\n    filter['command'] = new RegExp(query.command, 'i');\n  }\n\n  if (query.arguments) {\n    filter['arguments'] = new RegExp(query.arguments, 'i');\n  }\n\n  if (query.ppid) {\n    filter['ppid'] = new RegExp(query.ppid);\n  }\n\n  return Exec(exeArgs, function (err, output) {\n    if (err) {\n      return callback(err);\n    }\n    else {\n      var processList = parseGrid(output);\n      var resultList = [];\n\n      processList.forEach(function (p) {\n\n        var flt;\n        var type;\n        var result = true;\n\n        if (idList && idList.indexOf(String(p.pid)) < 0) {\n          return;\n        }\n\n        for (type in filter) {\n          flt = filter[type];\n          result = flt.test(p[type]) ? result : false;\n        }\n\n        if (result) {\n          resultList.push(p);\n        }\n      });\n\n      callback(null, resultList);\n    }\n  });\n};\n\n/**\n * Kill process\n * @param pid\n * @param {Object|String} signal\n * @param {String} signal.signal\n * @param {number} signal.timeout\n * @param next\n */\n\nexports.kill = function( pid, signal, next ){\n  //opts are optional\n  if(arguments.length == 2 && typeof signal == 'function'){\n    next = signal;\n    signal = undefined;\n  }\n\n  var checkTimeoutSeconds = (signal && signal.timeout) || 30;\n\n  if (typeof signal === 'object') {\n    signal = signal.signal;\n  }\n\n  try {\n    process.kill(pid, signal);\n  } catch(e) {\n    return next && next(e);\n  }\n\n  var checkConfident = 0;\n  var checkTimeoutTimer = null;\n  var checkIsTimeout = false;\n\n  function checkKilled(finishCallback) {\n    exports.lookup({ pid: pid }, function(err, list) {\n      if (checkIsTimeout) return;\n\n      if (err) {\n        clearTimeout(checkTimeoutTimer);\n        finishCallback && finishCallback(err);\n      } else if(list.length > 0) {\n        checkConfident = (checkConfident - 1) || 0;\n        checkKilled(finishCallback);\n      } else {\n        checkConfident++;\n        if (checkConfident === 5) {\n          clearTimeout(checkTimeoutTimer);\n          finishCallback && finishCallback();\n        } else {\n          checkKilled(finishCallback);\n        }\n      }\n    });\n  }\n\n  next && checkKilled(next);\n\n  checkTimeoutTimer = next && setTimeout(function() {\n    checkIsTimeout = true;\n    next(new Error('Kill process timeout'));\n  }, checkTimeoutSeconds * 1000);\n};\n\n/**\n * Parse the stdout into readable object.\n * @param {String} output\n */\n\nfunction parseGrid(output) {\n  if (!output) {\n    return [];\n  }\n  return formatOutput(TableParser.parse(output));\n}\n\n/**\n * format the structure, extract pid, command, arguments, ppid\n * @param data\n * @return {Array}\n */\n\nfunction formatOutput(data) {\n  var formatedData = [];\n  data.forEach(function (d) {\n    var pid = ( d.PID && d.PID[0] ) || ( d.ProcessId && d.ProcessId[0] ) || undefined;\n    var cmd = d.CMD || d.CommandLine || d.COMMAND || undefined;\n    var ppid = ( d.PPID && d.PPID[0] ) || ( d.ParentProcessId && d.ParentProcessId[0] ) || undefined;\n\n    if (pid && cmd) {\n      var command = cmd[0];\n      var args = '';\n\n      if (cmd.length > 1) {\n        args = cmd.slice(1);\n      }\n\n      formatedData.push({\n        pid: pid,\n        command: command,\n        arguments: args,\n        ppid: ppid\n      });\n    }\n  });\n\n  return formatedData;\n}\n","module.exports = require( './lib/index' );","/**\n *\n * 1, define the edge ( begin and end ) of every title field\n * 2, parse all the lines except the title line, get all the connected-domains\n * 3, group all the connected-domains vertically overlapped.\n * 4, a domain group belongs to a title field if they vertically overlapped\n * 5, calculate all the edge info through the group domain and title field relations.\n */\nvar ConnectedDomain = require('connected-domain');\nvar EMPTY_EX = /\\s/;\n\n/**\n * The output sting of cmd to parse\n * @param output\n * @returns {Array}\n */\nmodule.exports.parse = function (output) {\n\n  // Split into lines\n  // Basically, the EOL should be:\n  // - windows: \\r\\n\n  // - *nix: \\n\n  // But i'm trying to get every possibilities covered.\n  var linesTmp = output.split(/(\\r\\n)|(\\n\\r)|\\n|\\r/);\n\n  // valid lines\n  var lines = [];\n  // title field info, mapped with filed name.\n  var titleInfo = {};\n  // the two dimensional array of the lines\n  var twoDimArray = [];\n\n  // get rid of all the empty lines.\n  linesTmp.forEach(function (line) {\n    if (line && line.trim()) {\n      lines.push(line);\n    }\n  });\n\n  // build title fields edge info\n  // build two dimensional array for Connected-Domain to parse.\n  lines.forEach(function (line, index) {\n\n    // Treat the first line as the title fields line\n    if (index == 0) {\n      var fields = line.split(/\\s+/);\n\n      // record the beginning and ending for each field\n      fields.forEach(function (field, idx) {\n\n        if (field) {\n          var info = titleInfo[field] = {};\n          var indexBegin = line.indexOf(field);\n          var indexEnd = indexBegin + field.length;\n\n          if (idx == 0) {\n            info.titleBegin = 0;\n          }\n          else {\n            info.titleBegin = indexBegin;\n          }\n\n          if (idx == fields.length - 1) {\n            info.titleEnd = line.length - 1;\n          }\n          else {\n            info.titleEnd = indexEnd;\n          }\n        }\n      });\n    }\n    else {\n      twoDimArray[index - 1] = line.split('');\n    }\n  });\n\n  // In the connected-domain aspect of view, all the blanks are connected, and all the non-blanks are connected.\n  var connectedDomains = ConnectedDomain(twoDimArray, function (value) {\n    if (EMPTY_EX.test(value)) {\n      return -1;\n    }\n    else {\n      return 1;\n    }\n  }, true);\n\n  // all the connected domains grouped if they are vertically overlapped.\n  var valuesDomainsVerticalGroups = [];\n\n  // sore the domain list make 'x' in ascending order, it will prevent the situation that:\n  // 1, two domains are not overlapped, so two groups are created for them at first\n  // 2, another domain is found overlapped with both of the domains at the first step.\n  // 3, In this situation the three groups have to be merged, which is complicated to implement.\n  //\n  // If the list is sorted in this order, this situation can't happen, because:\n  // - 1, If two non-overlapped domains A, B ( the \"x\" value of A less than B ) are found first.\n  // - 2, Since the list is in 'x' ascending order, the 'x' values of the following domains must larger or equal to the \"x\" of B, which means they will never overlapped with domain A.\n  // - 3, So this situation can't happen.\n  connectedDomains.domains.sort(function (a, b) {\n    return a.bounding.x - b.bounding.x;\n  });\n\n  // Group domains vertically overlapped.\n  connectedDomains.domains.forEach(function (domain) {\n    // only handle un-empty domain\n    if (domain.identifier === 1) {\n      var overlapped = false;\n\n      // If overlapped\n      valuesDomainsVerticalGroups.forEach(function (group) {\n        var bounding = domain.bounding;\n        var left = bounding.x;\n        var right = bounding.x + bounding.w;\n\n        if (overlap(left, right, group.begin, group.end)) {\n\n          overlapped = true;\n          group.domains.push(domain);\n          group.begin = group.begin > left ? left : group.begin;\n          group.end = group.end < right ? right : group.end;\n        }\n      });\n\n      // If not overlapped with any group, then create a new group\n      if (!overlapped) {\n        valuesDomainsVerticalGroups.push({\n          begin: domain.bounding.x,\n          end: domain.bounding.x + domain.bounding.w,\n          domains: [domain]\n        });\n      }\n    }\n  });\n\n  // connect all the groups to the title fields\n  valuesDomainsVerticalGroups.forEach(function (group) {\n    var title = null;\n    var info = null;\n    var overlapped = false;\n\n    var minimunLeftDistance = null;\n    var nearestLeftTitle = null;\n    var distance = null;\n\n    for (title in titleInfo) {\n      info = titleInfo[title];\n\n      /**\n       * The calculation below is to find the nearest left title field to the group, in case no overlapped title field found.\n       */\n      if (group.begin > info.titleBegin) {\n        distance = group.begin - info.titleBegin;\n\n        if (!nearestLeftTitle || ( distance < minimunLeftDistance )) {\n          nearestLeftTitle = title;\n          minimunLeftDistance = distance;\n        }\n      }\n\n      if (overlap(group.begin, group.end, info.titleBegin, info.titleEnd)) {\n\n        overlapped = true;\n        info.titleBegin = info.titleBegin > group.begin ? group.begin : info.titleBegin;\n        info.titleEnd = info.titleEnd < group.end ? group.end : info.titleEnd;\n      }\n    }\n\n    // Groups not match any title field belongs to the nearest left title field\n    if (!overlapped && nearestLeftTitle) {\n      var nearestTitleField = titleInfo[nearestLeftTitle];\n      nearestTitleField.titleBegin = nearestTitleField.titleBegin > group.begin ? group.begin : nearestTitleField.titleBegin;\n      nearestTitleField.titleEnd = nearestTitleField.titleEnd < group.end ? group.end : nearestTitleField.titleEnd;\n\n    }\n  });\n\n  // The final result\n  var result = [];\n\n  // Since we have got all the title bounding edges, we can split all the lines into values now\n  lines.forEach(function (line, index) {\n    // skip the first line\n    if (index > 0) {\n\n      var lineItem = {};\n      var title = null;\n      var info = null;\n      var value = null;\n      for (title in titleInfo) {\n        info = titleInfo[title];\n        value = line.substring(info.titleBegin, info.titleEnd + 1);\n        lineItem[title] = splitValue(value.trim());\n      }\n\n      result.push(lineItem);\n    }\n  });\n\n  return result;\n};\n\n/**\n * Test if two bounding overlapped vertically\n * @param begin1\n * @param end1\n * @param begin2\n * @param end2\n * @returns {boolean}\n */\nfunction overlap(begin1, end1, begin2, end2) {\n  return ( begin1 > begin2 && begin1 < end2 ) || // 2--1--2--1 or 2--1--1--2\n    ( end1 > begin2 && end1 < end2 ) ||     // 1--2--1--2 or 2--1--1--2\n    ( begin1 <= begin2 && end1 >= end2 );// 21--12 or 1--2--2--1\n}\n\n/**\n * transform a string value into array. It's not just split(), but also to consider some chunk that wrapped with `\"`, like below:\n *      \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" --type=renderer --lang=zh-CN, `C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe` should be treated as a whole,\n *      also, be careful don't be mislead by format like `--name=\"neekey\"`, even more complicated: `--name=\"Neekey Ni\"`\n * so, `\"C:\\Program Files\\Internet Explorer\\iexplore.exe\" --name=\"Jack Neekey\"` should split into:\n *  - C:\\Program Files\\Internet Explorer\\iexplore.exe  // without `\"`\n *  - --name=\"Jack Neekey\"                             // with `\"`\n */\nfunction splitValue(value) {\n\n  var match = value.match(/\"/g);\n\n  // If only one \" found, then just ignore it\n  if (!match || match.length == 1) {\n    return value.split(/\\s+/);\n  }\n  else {\n    var result = [];\n    var chunk = null;\n    var ifInWrappedChunk = false;\n    var ifInPureWrappedChunk = false;\n    var quotaCount = 0;\n\n    // If the match length is a even, than nothing special, if a odd, ignore the last one.\n    var maxQuotaCount = match.length % 2 == 0 ? match.length : match.length - 1;\n\n    var previousItem = null;\n    var values = value.split('');\n\n    values.forEach(function (item, index) {\n\n      if (item !== ' ') {\n\n        if (item === '\"') {\n          // quota chunk begin\n          if (ifInWrappedChunk === false && quotaCount <= maxQuotaCount) {\n            ifInWrappedChunk = true;\n            quotaCount++;\n\n            // pure quota chunk begin\n            if (previousItem === ' ' || previousItem === null) {\n              ifInPureWrappedChunk = true;\n              chunk = '';\n            }\n            // normal continue\n            else {\n              chunk += item;\n            }\n          }\n          // quota chunk end\n          else if (ifInWrappedChunk === true) {\n            ifInWrappedChunk = false;\n            quotaCount++;\n\n            // pure quota chunk end\n            if (ifInPureWrappedChunk === true) {\n              ifInPureWrappedChunk = false;\n              result.push(chunk);\n              chunk = null;\n            }\n            // normal continue\n            else {\n              chunk += item;\n            }\n          }\n        }\n        // normal begin\n        else if (ifInWrappedChunk === false && ( previousItem === ' ' || previousItem === null )) {\n          chunk = item;\n        }\n        // normal or quota chunk continue.\n        else {\n          chunk += item;\n        }\n      }\n      // quota chunk continue, in quota chunk, blank is valid.\n      else if (ifInWrappedChunk) {\n        chunk += item;\n      }\n      // if not in quota chunk, them a blank means an end. But make sure chunk is exist, cause that could be blanks at the beginning.\n      else if (chunk !== null) {\n        result.push(chunk);\n        chunk = null;\n      }\n\n      previousItem = item;\n\n      // If this is the last one, but chunk is not end\n      if (index == ( values.length - 1 ) && chunk !== null) {\n        result.push(chunk);\n        chunk = null;\n      }\n    });\n\n    return result;\n  }\n}\n","import * as vscode from 'vscode';\nimport { fileURLToPath } from 'url';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as ps from 'ps-node';\n\nlet PORT = 6006;\nconst host = 'localhost';\n\n// import * as express from 'express';\n// import { resolveCliPathFromVSCodeExecutablePath } from 'vscode-test';\n// import createChannel from '@storybook/channel-websocket';\n// import * as Websocket from 'ws';\n// import { StoryTreeProvider, StoryObject, Story } from \"./tree-provider\";\n// import { StoryPickerProvider, StorySelection } from \"./picker-provider\";\n// const g = global as any;\n// g.Websocket = Websocket;\n// let storybookChannel : any;\n// const connectedOnce : Boolean = false;\n\n// const server = express();\nexport function activate(context: vscode.ExtensionContext) {\n\t// server.get('/', (req, res) => {\n\t// \tvscode.window.showInformationMessage('Aesop server online');\n\t// \tres.end();\n\t// });\n\t// server.listen(PORT);\n\n  //create disposable variable type, registers awaken command & opens webview\n\tlet disposable = vscode.commands.registerCommand('extension.aesopAwaken', () => {\n\n\t//define a path to the root working directory of the user\n\tconst rootDir = fileURLToPath(vscode.workspace.workspaceFolders[0].uri.toString(true));\n\n\t//check first to ensure that Storybook has been depended into the current working directory\n\t\tfs.access(path.join(rootDir, '/node_modules/@storybook'), (err) => {\n\t\t\t//if the filepath isn't found, show the user what Aesop is reading as the root path\n\t\t\tif (err) {\n\t\t\t\tvscode.window.showErrorMessage(`Aesop could not find Storybook as a dependency in the active folder, ${rootDir}`);\n\t\t\t}\telse {\n        //check to see if a storybook node process is already running\n        ps.lookup({\n\t\t\t\t\tcommand: 'node',\n\t\t\t\t\tpsargs: 'ux'\n\t\t\t\t}, (err, resultList) => {\n\t\t\t\t\tif (err){\n\t\t\t\t\t\tvscode.window.showErrorMessage(`Failed looking for running Node processes. Error: ${err}`);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t//potential problem: we may also need to account for running processes given no port flag\n\t\t\t\t\t\tresultList.forEach((process) => {\n\t\t\t\t\t\t\tvscode.window.showInformationMessage('Process:', process);\n\t\t\t\t\t\t\tvscode.window.showInformationMessage('JSON stringify', JSON.stringify(process));\n\t\t\t\t\t\t\t//check if any running processes are using the start-storybook script\n\t\t\t\t\t\t\tif(process.arguments[0].includes('start-storybook')){\n\t\t\t\t\t\t\t\t//stretch goal: check for multiple instances of storybook and reconcile\n\t\t\t\t\t\t\t\tvscode.window.showInformationMessage('PID: %s, COMMAND: %s, ARGUMENTS: %s', process.pid, process.command, process.arguments);\n\t\t\t\t\t\t\t\t//if so, extract port number and use that value to populate the webview with that contents\n\t\t\t\t\t\t\t\tconst sbProcess = process.arguments;\n\t\t\t\t\t\t\t\tconst portFlag = '-p';\n\t\t\t\t\t\t\t\tconst pFlagIndex = sbProcess.indexOf(portFlag);\n\t\t\t\t\t\t\t\tif (pFlagIndex !== -1){\n\t\t\t\t\t\t\t\t\tPORT = Number(process.arguments[pFlagIndex+1]);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t/*\n        //if not, we begin a process that starts with extracting existing npm scripts and changing them:\n        //check the existing storybook script in the package.json\n        fs.readFile(path.join(rootDir, 'package.json'), (err, data) => {\n          if (err) vscode.window.showErrorMessage(`Does this root folder contain a \"package.json\" file?`);\n          else {\n            //enter the package.JSON file and retrieve its contents as a string\n            let packageJSONText = data.toString();\n\n            //find where the \"storybook\" script is defined\n            let targetScriptStartIndex = packageJSONText.indexOf(`\"storybook\":`)+12;\n\n            //retrieve the value (i.e. the entire line of text) of the \"storybook\" script\n\t\t\t\t\t\tlet retrievedScript = packageJSONText.slice(targetScriptStartIndex, packageJSONText.indexOf('\\n'));\n\t\t\t\t\t\tvscode.window.showWarningMessage(retrievedScript);\n\n            //iterate through that text string and parse out important flags\n            //it is more helpful to split it into an array separated by whitespace to grab these\n            let retrievedScriptAsArray = retrievedScript.split(' ');\n            for (let i = 0; i < retrievedScriptAsArray.length; i++){\n\t\t\t\t\t\t\t//add flags\n              if (retrievedScriptAsArray[i] === '-p'){\n\t\t\t\t\t\t\t\tPORT = Number(retrievedScriptAsArray[i+1]);\n              };\n            }\n\n            //define the script text to execute to the virtual terminal instance\n            const bootStorybook = `${retrievedScript} --ci`\n\n            //now create a virtual terminal and execute our special npm script for it\n            //this first requires creating an eventEmitter that will fire that script\n            const scriptEmitter = new vscode.EventEmitter<string>();\n    \n            //we also define a slave process Pseudoterminal (allowing Aesop to control the terminal)\n            const pty: vscode.Pseudoterminal = {\n              onDidWrite: scriptEmitter.event,\n              open: () => scriptEmitter.fire(bootStorybook),\n              close: () => {},\n              handleInput: data => scriptEmitter.fire(data === '\\r' ? '\\r\\n' : data)\n            };\n\n            const virtualTerminal = vscode.window.createTerminal({name: 'sb-runner', pty});\n\t\t\t\t\t\t//processExecution?\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t\t*/\n\t\t\t}\n\t\t})\t\t\n\n\t\t//still inside our disposable variable, let's create the webview panel\n\t\tconst panel : vscode.WebviewPanel = vscode.window.createWebviewPanel(\n\t\t\t'aesop-sb',\n\t\t\t'Aesop',\n\t\t\tvscode.ViewColumn.Three,\n\t\t\t{\n\t\t\t\tenableCommandUris: true,\n\t\t\t\tenableScripts: true,\n\t\t\t\tportMapping: [\n\t\t\t\t\t{ webviewPort: 6006, extensionHostPort: 9009}\n\t\t\t\t]\n\t\t\t}\n\t\t);\n\n\t\tpanel.webview.html =\n\t\t\t`<!DOCTYPE html>\n\t\t\t<html lang=\"en\">\n\t\t\t\t<head>\n\t\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t\t\t\t\t<title>Aesop</title>\n\t\t\t\t</head>\n\t\t\t\t<body>\n\t\t\t\t\t<iframe src=\"http://${host}:${PORT}/?path=/story/welcome--to-storybook\" style=\"height:500px;width:500px;\"></iframe>\n\t\t\t\t</body>\n\t\t\t</html>`\n\t\t});\n\n\tcontext.subscriptions.push(disposable);\n}\n\nexport function deactivate() {\n\n}\n\n// vscode.commands.executeCommand(\"setContext\", \"is-running-storybooks-vscode\", true)\n\n//   let previewUri = vscode.Uri.parse(\"storybook://authority/preview\")\n//   class TextDocumentContentProvider implements vscode.TextDocumentContentProvider {\n//     public provideTextDocumentContent(uri: vscode.Uri): string {\n//       const port = vscode.workspace.getConfiguration(\"react-native-storybooks\").get(\"port\")\n//       const host = vscode.workspace.getConfiguration(\"react-native-storybooks\").get(\"host\")\n\n//       return `\n//             <style>iframe {\n//                 position: fixed;\n//                 border: none;\n//                 top: 0; right: 0;\n//                 bottom: 0; left: 0;\n//                 width: 100%;\n//                 height: 100%;\n//             }\n//             </style>\n\n//             <body onload=\"iframe.document.head.appendChild(ifstyle)\" style=\"background-color:red;margin:0px;padding:0px;overflow:hidden\">\n//                 <iframe src=\"http://${host}:${port}\" frameborder=\"0\"></iframe>\n//                 <p>If you're seeing this, something is wrong :) (can't find server at ${host}:${port})</p>\n//             </body>\n//             `\n//     }\n//   }\n\n//   let provider = new TextDocumentContentProvider()\n//   let registration = vscode.workspace.registerTextDocumentContentProvider(\"storybook\", provider)\n\n//   const storiesProvider = new StoryTreeProvider()\n//   vscode.window.registerTreeDataProvider(\"storybook\", storiesProvider)\n\n//   const pickerProvider = new StoryPickerProvider(storiesProvider)\n\n//   // Registers the storyboards command to trigger a new HTML preview which hosts the storybook server\n//   let disposable = vscode.commands.registerCommand(\"extension.showStorybookPreview\", () => {\n//     return vscode.commands.executeCommand(\"vscode.previewHtml\", previewUri, vscode.ViewColumn.Two, \"Storybooks\").then(\n//       success => {},\n//       reason => {\n//         vscode.window.showErrorMessage(reason)\n//       }\n//     )\n//   })\n\n//   context.subscriptions.push(disposable, registration)\n\n//   const host = vscode.workspace.getConfiguration(\"react-native-storybooks\").get(\"host\")\n//   const port = vscode.workspace.getConfiguration(\"react-native-storybooks\").get(\"port\")\n\n//   storybooksChannel = createChannel({ url: `ws://${host}:${port}`, async: true, onError: () => {} })\n//   var currentKind: string = null\n//   var currentStory: string = null\n//   var currentStoryId: string = null\n\n//   // Create a statusbar item to reconnect, when we lose connection\n//   const reconnectStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left)\n//   reconnectStatusBarItem.command = \"extension.restartConnectionToStorybooks\"\n//   if (connectedOnce) {\n//     reconnectStatusBarItem.text = \"Reconnect Storybooks\"\n//     reconnectStatusBarItem.color = \"#FF8989\"\n//   } else {\n//     reconnectStatusBarItem.text = \"Connect to Storybooks\"\n//   }\n\n//   reconnectStatusBarItem.hide()\n\n//   // So when we re-connect, callbacks can happen on the new socket connection\n//   const registerCallbacks = channel => {\n//     // Called when we get stories from the RN client\n//     channel.on(\"setStories\", data => {\n//       const filter = vscode.workspace.getConfiguration(\"react-native-storybooks\").get(\"storybookFilterRegex\") as string\n//       const regex = new RegExp(filter)\n//       let stories: Story[] = []\n//       if (Array.isArray(data.stories)) {\n//         let kinds: { [key: string]: StoryObj[] } = {}\n//         const storydata = data.stories.filter(s => s.kind.match(regex))\n\n//         storydata.map(story => {\n//           story.stories.map(singleStory => {\n//             if (kinds[story.kind] == undefined) {\n//               // kinds[story.kind] = [story.name]\n//               kinds[story.kind] = [{ name: singleStory, id: singleStory }]\n//             } else {\n//               kinds[story.kind].push({ name: singleStory, id: singleStory })\n//             }\n//           })\n//         })\n//         Object.keys(kinds).forEach(function(key) {\n//           stories.push({\n//             kind: key,\n//             stories: kinds[key]\n//           })\n//         })\n//       } else {\n//         let kinds: { [key: string]: StoryObj[] } = {}\n//         Object.keys(data.stories).forEach(function(key) {\n//           const story = data.stories[key]\n//           if (story.kind.match(regex)) {\n//             if (kinds[story.kind] == undefined) {\n//               // kinds[story.kind] = [story.name]\n//               kinds[story.kind] = [{ name: story.name, id: story.id }]\n//             } else {\n//               kinds[story.kind].push({ name: story.name, id: story.id })\n//             }\n//           }\n//         })\n//         Object.keys(kinds).forEach(function(key) {\n//           stories.push({\n//             kind: key,\n//             stories: kinds[key]\n//           })\n//         })\n//       }\n//       storiesProvider.stories = stories\n//       storiesProvider.refresh()\n//       reconnectStatusBarItem.hide()\n//     })\n\n//     // When the server in RN starts up, it asks what should be default\n//     channel.on(\"getCurrentStory\", () => {\n//       storybooksChannel.emit(\"setCurrentStory\", {\n//         storyId: currentStoryId\n//       })\n//     })\n\n//     // The React Native server has closed\n//     channel.transport.socket.onclose = () => {\n//       storiesProvider.stories = []\n//       storiesProvider.refresh()\n//       reconnectStatusBarItem.show()\n//     }\n\n//     channel.emit(\"getStories\")\n//   }\n//   registerCallbacks(storybooksChannel)\n\n//   vscode.commands.registerCommand(\"extension.searchStories\", () => {\n//     vscode.window.showQuickPick(pickerProvider.toList()).then((picked: string) => {\n//       const setParams = pickerProvider.getParts(picked)\n//       setCurrentStory(setParams)\n//     })\n//   })\n\n//   // Allow clicking, and keep state on what is selected\n//   vscode.commands.registerCommand(\"extension.openStory\", (section, story) => {\n//     // Handle a Double click\n//     if (currentStoryId === story.id && currentKind === section.kind && currentStory === story.name) {\n//       findFileForStory(section.kind, story.name).then(results => {\n//         if (results) {\n//           vscode.workspace.openTextDocument(results.uri).then(doc => {\n//             vscode.window.showTextDocument(doc).then(shownDoc => {\n//               let range = doc.lineAt(results.line - 1).range\n//               vscode.window.activeTextEditor.selection = new vscode.Selection(range.start, range.end)\n//               vscode.window.activeTextEditor.revealRange(range, vscode.TextEditorRevealType.InCenter)\n//             })\n//           })\n//         }\n//       })\n//       return\n//     }\n\n//     setCurrentStory({ storyId: story.id, kind: section.kind, story: story.name })\n//   })\n\n//   function setCurrentStory(params: StorySelection) {\n//     const currentChannel = () => storybooksChannel\n//     currentKind = params.kind\n//     currentStory = params.story\n//     currentStoryId = params.storyId\n//     currentChannel().emit(\"setCurrentStory\", params)\n//   }\n\n//   vscode.commands.registerCommand(\"extension.connectToStorybooks\", () => {\n//     storybooksChannel = createChannel({ url: `ws://${host}:${port}`, async: true, onError: () => {} })\n//     registerCallbacks(storybooksChannel)\n//   })\n\n//   vscode.commands.registerCommand(\"extension.restartConnectionToStorybooks\", () => {\n//     storybooksChannel = createChannel({ url: `ws://${host}:${port}`, async: true, onError: () => {} })\n//     registerCallbacks(storybooksChannel)\n//   })\n\n//   // These are a bit alpha-y, as I don't think I can control what is showing as selected inside the VS Code UI\n//   vscode.commands.registerCommand(\"extension.goToNextStorybook\", () => {\n//     const stories = storiesProvider.stories\n//     const currentSection = stories.find(s => s.kind === currentKind)\n//     const currentStories = currentSection.stories\n//     const currentIndex = currentStories.map(e => e.id).indexOf(currentStoryId)\n//     if (currentIndex === currentStories.length) {\n//       // go around or something\n//       vscode.commands.executeCommand(\"extension.openStory\", currentSection, currentStories[0])\n//     } else {\n//       vscode.commands.executeCommand(\"extension.openStory\", currentSection, currentStories[currentIndex + 1])\n//     }\n//   })\n\n//   vscode.commands.registerCommand(\"extension.goToPreviousStorybook\", () => {\n//     const stories = storiesProvider.stories\n//     const currentSection = stories.find(s => s.kind === currentKind)\n//     const currentStories = currentSection.stories\n//     const currentIndex = currentStories.map(e => e.id).indexOf(currentStoryId)\n//     if (currentIndex === 0) {\n//       // go around or something\n//       vscode.commands.executeCommand(\"extension.openStory\", currentSection, currentStories[currentStories.length - 1])\n//     } else {\n//       vscode.commands.executeCommand(\"extension.openStory\", currentSection, currentStories[currentIndex - 1])\n//     }\n//   })\n\n//   vscode.commands.registerCommand(\"extension.expandAllStories\", () => {\n//     storiesProvider.expandAll()\n//   })\n\n//   vscode.commands.registerCommand(\"extension.collapseAllStories\", () => {\n//     storiesProvider.collapseAll()\n//   })\n// }\n\n// // Loop through all globbed stories,\n// // reading the files for the kind and the story name\n\n// const findFileForStory = async (kind: string, story: string): Promise<{ uri: vscode.Uri; line: number } | null> => {\n//   return new Promise<{ uri: vscode.Uri; line: number }>((resolve, reject) => {\n//     const regex = vscode.workspace.getConfiguration(\"react-native-storybooks\").get(\"storyRegex\") as string\n\n//     const root = vscode.workspace.workspaceFolders\n//     vscode.workspace.findFiles(regex, \"**/node_modules\").then(files => {\n//       let found = false\n//       for (const file of files) {\n//         const content = fs.readFileSync(file.fsPath, \"utf8\")\n//         if (content.includes(kind) && content.includes(story)) {\n//           const line = content.split(story)[0].split(\"\\n\").length\n//           resolve({ uri: file, line })\n//           found = true\n//         }\n//       }\n//       if (!found) {\n//         resolve(null)\n//       }\n//     })\n//   })\n// }\n\n// export function deactivate() {\n//   storybooksChannel.transport.socket.close()\n// }\n\n/*\nto-do:\n\tfigure out how to iteratively call sb scripts within our webview\n\twebview messages / scripts to reload\n\tfigure out how to use a tsx rule in webpack to execute scripts\n\tsignal babel to interpret this block as tsx, e.g. something like: //@tsx babel//\n\n//THIS WORKS, but we have no access to the DOM inside our webview//\n\t//now let's read SB's outputted index.html file, and parse out what we need\n\t\tfs.readFile(path.join(rootDir, '/node_modules/@storybook/core/dist/public/index.html'), (err, data) => {\n\t\t\tif (err) console.error(err);\n\t\t\telse {\n\t\t\t\tlet pulledHTML = data.toString();\n\t\t\t\tlet targetPoint = pulledHTML.indexOf('</body>');\n\t\t\t\tlet firstHalf = pulledHTML.slice(0, targetPoint);\n\t\t\t\tlet secondHalf = pulledHTML.slice(targetPoint);\n\t\t\t\tpulledHTML = firstHalf.concat(payloadScript).concat(secondHalf);\n\t\t\t\tfs.writeFile(path.join(rootDir, '/node_modules/@storybook/core/dist/public/index.html'), pulledHTML, (err) => {\n\t\t\t\t\tif (err) console.error(err);\n\t\t\t\t\telse {\n\t\t\t\t\t\tvscode.window.showInformationMessage('Successfully injected script');\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t//declare an empty array (of strings) to push our scripts to during the next part\n\t\tconst scriptArray : Array<string> = [];\n\t\t//define a path to the root working directory of the user\n\t\tconst rootDir = fileURLToPath(vscode.workspace.workspaceFolders[0].uri.toString(true));\n\t\t//now let's read SB's outputted index.html file, and parse out what we need\n\t\tfs.readFile(path.join(rootDir, '/node_modules/@storybook/core/dist/public/index.html'), (err, data) => {\n\t\t\tif (err) console.error(err);\n\t\t\telse {\n\t\t\t\t//if we've read the HTML file, take its contents and stringify it\n\t\t\t\tlet outputFile = data.toString();\n\t\t\t\t// this log shows what our eventual permutations would look like as we carve out the scripts\n\t\t\t\t// vscode.window.showWarningMessage(`what's in it: ${outputFile.slice(outputFile.indexOf('<body>')+6, outputFile.indexOf('</body>'))} \\n`)\n\t\t\t\t//split out the body section of the retrieved html file\n\t\t\t\toutputFile = outputFile.slice(outputFile.indexOf('<body>')+6, outputFile.indexOf('</body>'));\n\t\t\t\tvscode.window.showWarningMessage(`${outputFile} \\n`)\n\n\t\t\t\t//this loop will peel out all the scripts so long as there are any to rip out\n\t\t\t\twhile (outputFile.includes(`\"<script src=`)){\n\t\t\t\t\t//we push just what we need (the src attributes), leaving the <script>...</script> tags behind\n\t\t\t\t\tlet temp = outputFile.slice(outputFile.indexOf(`<script src=\"`)+12, outputFile.indexOf(`\"></script>`));\n\t\t\t\t\tscriptArray.push(temp);\n\t\t\t\t\toutputFile = outputFile.slice(outputFile.indexOf(`\"></script>`)+10);\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\n<div id=\"root\"></div>\n<div id=\"docs-root\"></div>\t\n\t<div id=\"scriptExecute\">\n\t<script>window.acquireVsCodeApi = acquireVsCodeApi();</script>\n\t<script>window['DOCS_MODE'] = false;</script>\n\t<script>\n\t\t${\n\t\t\tscriptArray.map( (el) => {\n\t\t\t\tif (el.includes(\"./sb_dll\")){\n\t\t\t\t\tlet uiScript = document.createElement(\"script\");\n\t\t\t\t\tuiScript.async = true;\n\t\t\t\t\tuiScript.defer = true;\n\t\t\t\t\tuiScript.referrerPolicy = \"origin\";\n\t\t\t\t\tuiScript.src = path.join(rootDir, `/node_modules/@storybook/core/dll/${el}`);\n\t\t\t\t\tdocument.getElementById(\"scriptExecute\").appendChild(uiScript);\n\t\t\t\t}\telse {\n\t\t\t\t\tlet capturedScript = document.createElement(\"script\");\n\t\t\t\t\tcapturedScript.async = true;\n\t\t\t\t\tcapturedScript.defer = true;\n\t\t\t\t\tcapturedScript.referrerPolicy = \"origin\";\n\t\t\t\t\tcapturedScript.src = path.join(rootDir, `/node_modules/@storybook/core/dist/public/${el}`);\n\t\t\t\t\tdocument.getElementById(\"scriptExecute\").appendChild(capturedScript);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t</script>\n</div>\n\n\tdisposable = vscode.commands.registerCommand('extension.getStories', () => {\n\t\tbuild a command that retrieves Storybook files on startup\n\t\tcan be executed later if Storybook server is spun up after the extension opens\n\t\t\n\t\talso register this command at startup to crawl the file path\n\t\t${vscode.commands.executeCommand('extension.getStories')}\n\t\tvscode.window.showInformationMessage('Aesop is reading from your Storybook.');\n\n\t\tdefine a path to SB webpack bundle outputs (in user workspace /node_modules/ folder)\n\t\tif (vscode.workspace.workspaceFolders[0] !== undefined){\n\t\t\tconst distGlob = new vscode.RelativePattern(vscode.workspace.workspaceFolders[0], \"**(remove)/node_modules/@storybook/core/dist/public\");\n\t\t\t//instantiate a watcher to listen for fs path changes (e.g. file creation/update)\n\t\t\t//bools = options for ignoreCreateEvents?, ignoreChangeEvents?, ignoreDeleteEvents?\t\n\t\t\tconst observer = vscode.workspace.createFileSystemWatcher(distGlob, false, false, false);\n\t\t\t// observer.onDidChange = //resolve//;\t\t// observer.onDidCreate = //resolve//;\n\t\t\t//extract index.html file that outputs into SB's preview pane\n\t\t\tconst htmlGlob = new vscode.RelativePattern(vscode.workspace.workspaceFolders[0], \"*(remove)/node_modules/@storybook/core/dist/public/*.html\");\n\t\t\t//extract necessary bundle scripts to leverage in-app dependencies\n\t\t\tconst scriptGlob = new vscode.RelativePattern(vscode.workspace.workspaceFolders[0], \"*(remove)/node_modules/@storybook/core/dist/public/*.js\");\n\n\t\t\tconsole.log(vscode.Uri.file(fileURLToPath(`/node_modules/@storybook/core/dist/public`)));\n\n\t\t\t//do we need to resolve the Storybook UI script from the /dll/ folder?\n\t\t\t//if extract methods above fail, determine logic to parse out HTML/.js scripts (index 0?);\n\t\t\t//retrieve files with findFiles/relativeFilePath\n\t\t\tconst arrayOfScripts = vscode.workspace.findFiles(distGlob, null, 100);\n\t\t\t//dev check: have we successfully pulled down script files?\n\t\t\t//if so, should we then store them locally, or is there no point?\n\t\t\tif (arrayOfScripts !== undefined){\n\t\t\t\tvscode.window.showInformationMessage(\"Hey, dog: \" + `${arrayOfScripts}`);\n\t\t\t}\n\n\t\t\tvscode.window.showInformationMessage(`\n\t\t\trootPath: ${vscode.workspace.workspaceFolders[0]},\n\t\t\tvscode.Uri: ${vscode.Uri},\n\t\t\tworkspace: ${vscode.workspace},\n\t\t\tdistGlob: ${distGlob.toString()},\n\t\t\thtmlGlob: ${htmlGlob.toString()},\n\t\t\tscriptGlob: ${scriptGlob.toString()}\n\t\t\t`);\n\t\t};\n\n\t\tvscode.window.showInformationMessage(`\n\t\t\trootPath: ${vscode.workspace.workspaceFolders[0].uri.toString()},\\n\n\t\t\tvscode URI parseTest: ${vscode.Uri.parse('file://'+ '/node_modules/@storybook/core/dist/public/index.html')},\\n\n\t\t\tvscode URI parsed w escape: ${vscode.Uri.parse('file://'+ '/node_modules/\\@storybook/core/dist/public/index.html')},\\n\n\t\t\tvscode URI  file Test: ${vscode.Uri.file('node_modules/@storybook/core/dist/public/index.html')}\n\t\t\t`);\n\t\t\t\n\t\tconsole.log(`\n\t\trootPath: ${vscode.workspace.workspaceFolders[0]},\n\t\tvscode.Uri: ${vscode.Uri},\n\t\tworkspace: ${vscode.workspace},\n\t\tfileSys: ${vscode.Uri.file(path.join('/'))}`);\n  });\n  */","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"url\");","module.exports = require(\"vscode\");"],"sourceRoot":""}
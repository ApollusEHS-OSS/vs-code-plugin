{"version":3,"sources":["../webpack/bootstrap",".././node_modules/connected-domain/index.js",".././node_modules/connected-domain/lib/connected-domain.js",".././node_modules/ps-node/index.js",".././node_modules/ps-node/lib/index.js",".././node_modules/table-parser/index.js",".././node_modules/table-parser/lib/index.js",".././node_modules/ws/index.js",".././node_modules/ws/lib/buffer-util.js",".././node_modules/ws/lib/constants.js",".././node_modules/ws/lib/event-target.js",".././node_modules/ws/lib/extension.js",".././node_modules/ws/lib/limiter.js",".././node_modules/ws/lib/permessage-deflate.js",".././node_modules/ws/lib/receiver.js",".././node_modules/ws/lib/sender.js",".././node_modules/ws/lib/stream.js",".././node_modules/ws/lib/validation.js",".././node_modules/ws/lib/websocket-server.js",".././node_modules/ws/lib/websocket.js",".././src/extension.ts","../external \"child_process\"","../external \"crypto\"","../external \"events\"","../external \"fs\"","../external \"http\"","../external \"https\"","../external \"net\"","../external \"os\"","../external \"path\"","../external \"stream\"","../external \"tls\"","../external \"url\"","../external \"vscode\"","../external \"zlib\""],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;AClFA,iBAAiB,mBAAO,EAAE,uFAAwB,G;;;;;;;;;;;ACAlD;AACA;AACA;;AAEA;AACA,WAAW,MAAM;AACjB,WAAW,SAAS;AACpB,WAAW,QAAQ;AACnB,YAAY,OAAO,GAAG,YAAY,2BAA2B,aAAa,sBAAsB,EAAE,qCAAqC;AACvI;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;;AAEL;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,aAAa;;AAEb;;AAEA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;AC/PA,iBAAiB,mBAAO,CAAC,kDAAO;;;;;;;;;;;;ACAhC,mBAAmB,mBAAO,CAAC,oCAAe;AAC1C;AACA,kBAAkB,mBAAO,CAAC,0DAAc;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAO,CAAC,cAAI;;AAE5B;AACA;AACA,UAAU;AACV,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,aAAa;AACxB,WAAW,SAAS;AACpB,WAAW,YAAY;AACvB,WAAW,SAAS;AACpB,YAAY;AACZ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oBAAoB,WAAW;AAC/B;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;;AAEH;AACA;;;;;;;;;;;;ACpSA,iBAAiB,mBAAO,EAAE,6DAAa,G;;;;;;;;;;;ACAvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAO,CAAC,kEAAkB;AAChD;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,yCAAyC;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;;;;;;;;;;;;ACvTa;;AAEb,kBAAkB,mBAAO,CAAC,2DAAiB;;AAE3C,kCAAkC,mBAAO,CAAC,qDAAc;AACxD,mBAAmB,mBAAO,CAAC,yEAAwB;AACnD,qBAAqB,mBAAO,CAAC,yDAAgB;AAC7C,mBAAmB,mBAAO,CAAC,qDAAc;;AAEzC;;;;;;;;;;;;;ACTa;;AAEb,OAAO,eAAe,GAAG,mBAAO,CAAC,uDAAa;;AAE9C;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,EAAE;AACb,YAAY,OAAO;AACnB,YAAY;AACZ;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,mBAAO,CAAC,oIAAY;AACzC;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjJa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,qCAAqC;AAClD,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,UAAU;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,UAAU;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACzKa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,wBAAwB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAQ,mBAAmB;AAC3B;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO,6BAA6B;AACpC;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP,+DAA+D,EAAE;AACjE;AACA,KAAK;AACL;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP,+DAA+D,EAAE;AACjE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,EAAE;AACnE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,iEAAiE,EAAE;AACnE;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA,iEAAiE,EAAE;AACnE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP,+DAA+D,EAAE;AACjE;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,EAAE,GAAG,EAAE;AAC1D,0BAA0B;AAC1B,eAAe;AACf;AACA,oBAAoB;AACpB,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA,kBAAkB;;;;;;;;;;;;;AC9NL;;AAEb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACrDa;;AAEb,aAAa,mBAAO,CAAC,kBAAM;;AAE3B,mBAAmB,mBAAO,CAAC,2DAAe;AAC1C,gBAAgB,mBAAO,CAAC,mDAAW;AACnC,OAAO,oBAAoB,GAAG,mBAAO,CAAC,uDAAa;;AAEnD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,iBAAiB;AAC9B;AACA,aAAa,iBAAiB;AAC9B;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAwC,IAAI;AAC5C;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,gDAAgD,IAAI,KAAK,MAAM;AAC/D;AACA;AACA;AACA,WAAW;AACX;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8CAA8C,IAAI,KAAK,MAAM;AAC7D;AACA;AACA,SAAS;AACT,gDAAgD,IAAI;AACpD;;AAEA;AACA,OAAO;AACP,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;AAEP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC,SAAS;AACzC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9fa;;AAEb,OAAO,WAAW,GAAG,mBAAO,CAAC,sBAAQ;;AAErC,0BAA0B,mBAAO,CAAC,yEAAsB;AACxD;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,uDAAa;AACzB,OAAO,gCAAgC,GAAG,mBAAO,CAAC,2DAAe;AACjE,OAAO,iCAAiC,GAAG,mBAAO,CAAC,yDAAc;;AAEjE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA,mDAAmD,aAAa;AAChE;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC,oBAAoB;AACxD;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,iDAAiD,aAAa;AAC9D;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,cAAc,kBAAkB;AAChC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,6BAA6B;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;;AAEA;AACA,0DAA0D,KAAK;AAC/D;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA,WAAW,OAAO;AAClB,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA,yCAAyC,QAAQ;AACjD;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC5ea;;AAEb,OAAO,iBAAiB,GAAG,mBAAO,CAAC,sBAAQ;;AAE3C,0BAA0B,mBAAO,CAAC,yEAAsB;AACxD,OAAO,eAAe,GAAG,mBAAO,CAAC,uDAAa;AAC9C,OAAO,oBAAoB,GAAG,mBAAO,CAAC,yDAAc;AACpD,OAAO,4BAA4B,GAAG,mBAAO,CAAC,2DAAe;;AAE7D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,mBAAmB;AAChC,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,MAAM;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACvWa;;AAEb,OAAO,SAAS,GAAG,mBAAO,CAAC,sBAAQ;;AAEnC;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;ACpJa;;AAEb;AACA,sBAAsB,mBAAO,CAAC,wIAAgB;;AAE9C;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7Ba;;AAEb,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,OAAO,aAAa,GAAG,mBAAO,CAAC,sBAAQ;AACvC,OAAO,6BAA6B,GAAG,mBAAO,CAAC,kBAAM;;AAErD,0BAA0B,mBAAO,CAAC,yEAAsB;AACxD,kBAAkB,mBAAO,CAAC,uDAAa;AACvC,OAAO,gBAAgB,GAAG,mBAAO,CAAC,uDAAa;AAC/C,OAAO,OAAO,GAAG,mBAAO,CAAC,uDAAa;;AAEtC,iCAAiC,GAAG;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA,aAAa,QAAQ;AACrB;AACA,aAAa,SAAS;AACtB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB,aAAa,OAAO;AACpB,aAAa,iBAAiB;AAC9B;AACA,aAAa,OAAO;AACpB,aAAa,YAAY;AACzB,aAAa,SAAS;AACtB,aAAa,SAAS;AACtB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kDAAkD;AAC3E;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB,aAAa,qBAAqB;AAClC,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA,gDAAgD,SAAS;AACzD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP,gDAAgD,MAAM;AACtD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,0BAA0B;AACrC,YAAY,SAAS;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,WAAW;AACtB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,KAAK,GAAG,mBAAmB;AAC7C;AACA,yBAAyB,EAAE,IAAI,WAAW;AAC1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACrZa;;AAEb,qBAAqB,mBAAO,CAAC,sBAAQ;AACrC,cAAc,mBAAO,CAAC,oBAAO;AAC7B,aAAa,mBAAO,CAAC,kBAAM;AAC3B,YAAY,mBAAO,CAAC,gBAAK;AACzB,YAAY,mBAAO,CAAC,gBAAK;AACzB,OAAO,0BAA0B,GAAG,mBAAO,CAAC,sBAAQ;AACpD,OAAO,MAAM,GAAG,mBAAO,CAAC,gBAAK;;AAE7B,0BAA0B,mBAAO,CAAC,yEAAsB;AACxD,iBAAiB,mBAAO,CAAC,qDAAY;AACrC,eAAe,mBAAO,CAAC,iDAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,uDAAa;AACzB,OAAO,wCAAwC,GAAG,mBAAO,CAAC,6DAAgB;AAC1E,OAAO,gBAAgB,GAAG,mBAAO,CAAC,uDAAa;AAC/C,OAAO,WAAW,GAAG,mBAAO,CAAC,2DAAe;;AAE5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B,aAAa,kBAAkB;AAC/B,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,WAAW;AACxB,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa,EAAE;AACf,aAAa,OAAO;AACpB,aAAa,QAAQ;AACrB;AACA,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,QAAQ;AACrB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,kDAAkD,OAAO;AACzD;AACA;AACA;AACA,gBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA,qBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,iBAAiB;AAC5B,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,iBAAiB;AAC5B;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uCAAuC,qBAAqB;AAC5D,gCAAgC,4BAA4B;AAC5D;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA,oCAAoC,cAAc;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB,GAAG,mBAAmB;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,uCAAuC,eAAe;AACtD;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,cAAc;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,gCAAgC;AAC3C;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB,WAAW,EAAE;AACb,WAAW,SAAS;AACpB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,qBAAqB;AAChE,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,qCAAqC;AAChD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC34BA,2DAAiC;AACjC,oDAAoC;AACpC,qDAA6B;AAC7B,+CAAyB;AACzB,iFAA8B;AAC9B,gFAA+C;AAI/C,8EAAgC;AAIhC,MAAM,CAAC,GAAG,MAAa,CAAC;AACxB,CAAC,CAAC,SAAS,GAAG,SAAS,CAAC;AACxB,IAAI,iBAAsB,CAAC;AAC3B,IAAI,qBAAqB,GAAa,KAAK,CAAC;AAE5C;;;;;;EAME;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAyOE;AACF;;;;;;;;;;;;;;;;;;;;;;EAsBE;AACF;;;;;;;;EAQE;AACD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAiQC;AACF,oCAAoC;AACpC,oDAAoD;AACpD,uHAAuH;AACvH,iFAAiF;AACjF,2FAA2F;AAC3F,6GAA6G;AAE7G,qDAAqD;AACrD,2EAA2E;AAC3E,0BAA0B;AAC1B,oCAAoC;AACpC,+DAA+D;AAC/D,mEAAmE;AACnE,oEAAoE;AACpE,yCAAyC;AACzC,yBAAyB;AACzB,YAAY;AACZ,UAAU;AACV,sBAAsB;AACtB,wBAAwB;AACxB,UAAU;AACV,SAAS;AACT,OAAO;AACP,IAAI;AAEJ,SAAgB,QAAQ,CAAC,OAAgC;IAExD,IAAI,IAAI,GAAY,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IAC3E,IAAI,IAAI,GAAY,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IAE3E,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,mBAAmB,IAAI,EAAE,CAAC,CAAC;IAEhE,mDAAmD;IACnD,MAAM,CAAC,QAAQ,CAAC,cAAc,CAAC,YAAY,EAAE,aAAa,EAAE,IAAI,CAAC,CAAC;IAElE,qEAAqE;IACrE,IAAI,UAAU,GAAG,MAAM,CAAC,QAAQ,CAAC,eAAe,CAAC,uBAAuB,EAAE,GAAG,EAAE;QAE9E,6EAA6E;QAC7E,IAAI,gBAAgB,GAAa,KAAK,CAAC;QAEvC,mEAAmE;QACnE,IAAI,OAAO,GAAa,KAAK,CAAC;QAE9B,oDAAoD;QACpD,MAAM,OAAO,GAAG,mBAAa,CAAC,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC,CAAC;QAEvF,sEAAsE;QACtE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,0BAA0B,CAAC,EAAE,CAAC,GAAG,EAAE,EAAE;YAEjE,MAAM,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,mBAAmB,CAAC,MAAM,CAAC,kBAAkB,CAAC,IAAI,CAAC,CAAC;YACrF,UAAU,CAAC,IAAI,GAAG,6CAA6C;YAC/D,UAAU,CAAC,KAAK,GAAG,SAAS,CAAC;YAE7B,mFAAmF;YACnF,IAAI,GAAG,EAAE;gBACR,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,wEAAwE,OAAO,EAAE,CAAC,CAAC;gBAClH,UAAU,CAAC,OAAO,EAAE,CAAC;aACrB;iBAAM;gBACN,6DAA6D;gBAC7D,IAAI,gBAAgB,KAAK,KAAK,EAAC;oBAE9B,EAAE,CAAC,MAAM,CAAC,EAAC,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAC,EAAE,CAAC,GAAG,EAAE,UAAU,EAAE,EAAE;wBAC9D,IAAI,GAAG,EAAC;4BACP,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,qDAAqD,GAAG,EAAE,CAAC,CAAC;4BAC3F,UAAU,CAAC,OAAO,EAAE,CAAC;yBACrB;6BAAM;4BAEN,yEAAyE;4BACzE,UAAU,CAAC,IAAI,GAAG,wCAAwC,CAAC;4BAE3D,0FAA0F;4BAC1F,UAAU,CAAC,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE;gCAE9B,mBAAmB;gCACnB,EAAE,CAAC,SAAS,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE,yBAAyB,EACtE,CAAC,GAAG,EAAE,EAAE,GAAE,OAAO,CAAC,GAAG,CAAC,oDAAoD,GAAG,EAAE,CAAC,GAAC,CAAC,CAAC;gCAEnF,wDAAwD;gCACxD,IAAG,OAAO,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,WAAW,CAAC,EAAC;oCAE7C,uEAAuE;oCACvE,0FAA0F;oCAC1F,MAAM,UAAU,GAAG,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;oCACnD,IAAI,UAAU,KAAK,CAAC,CAAC,EAAC;wCACrB,IAAI,GAAG,QAAQ,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU,GAAC,CAAC,CAAC,CAAC,CAAC;qCACjD;oCAED,mBAAmB;oCACnB,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE;gBACvC,OAAO,CAAC,GAAG,aAAa,OAAO,CAAC,OAAO,gBAAgB,OAAO,CAAC,SAAS;sCAClD,IAAI,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE,GAAE,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,GAAC,CAAC,CAAC;oCAElE,0EAA0E;oCAC1E,OAAO,GAAG,IAAI,CAAC;oCACf,UAAU,CAAC,IAAI,GAAG,8CAA8C,CAAC;iCAEjE,wDAAuD;4BACzD,CAAC,CAAC,EAAC,iCAAiC;4BAEpC,kEAAkE;4BAClE,gBAAgB,GAAG,IAAI,CAAC;4BAExB,mFAAmF;4BACnF,IAAI,gBAAgB,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK,EAAC;gCAElD,0FAA0F;gCAC1F,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,cAAc,CAAC,EAAE,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;oCAC7D,IAAI,GAAG,EAAC;wCACP,MAAM,CAAC,MAAM,CAAC,gBAAgB,CAAC,+BAA+B,OAAO,sCAAsC,CAAC,CAAC;qCAC7G;yCAAM;wCACN,UAAU,CAAC,IAAI,GAAG,4DAA4D,CAAC;wCAE/E,oEAAoE;wCACpE,IAAI,WAAW,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,CAAC,CAAC;wCAC9C,IAAI,eAAe,GAAG,WAAW,CAAC,OAAO,CAAC,SAAS,CAAC;wCAEpD,mBAAmB;wCACnB,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE;YAC5C,eAAe,EAAE,EAAE,CAAC,GAAG,EAAE,EAAE,GAAE,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,GAAC,CAAC,CAAC;wCAElD,qFAAqF;wCACrF,mFAAmF;wCACnF,IAAI,oBAAoB,GAAG,eAAe,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;wCACtD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,oBAAoB,CAAC,MAAM,EAAE,CAAC,EAAE,EAAC;4CACpD,+EAA+E;4CAC/E,IAAI,oBAAoB,CAAC,CAAC,CAAC,KAAK,IAAI,EAAC;gDACpC,IAAI,GAAG,QAAQ,CAAC,oBAAoB,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC,CAAC;gDAE3C,mBAAmB;gDACnB,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE,uBAAuB,QAAQ,CAAC,oBAAoB,CAAC,CAAC,GAAC,CAAC,CAAC,CAAC;oCAChF,IAAI,IAAI,EAAE,CAAC,GAAG,EAAE,EAAE,GAAE,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,GAAC,CAAC,CAAC;gDAE/D,MAAM;6CACN;iDAAM,IAAI,CAAC,KAAK,oBAAoB,CAAC,MAAM,GAAC,CAAC,EAAC;gDAC9C,iFAAiF;gDACjF,kDAAkD;gDAElD,mBAAmB;gDACnB,EAAE,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,UAAU,CAAC,EAAE;6CACb,IAAI,IAAI,EAAE,CAAC,GAAG,EAAE,EAAE,GAAE,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,GAAC,CAAC,CAAC;6CACxE;yCACD;wCAED,sEAAsE;wCACtE,wEAAwE;wCAExE,yDAAyD;wCACzD,MAAM,KAAK,GAAG,aAAa,CAAC,KAAK,CAAC,KAAK,EAAE,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC,CAAC;wCAE/D,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,qDAAqD,CAAC,CAAC;wCAE5F,KAAK,CAAC,MAAM,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC;wCAEjC,IAAI,OAAO,GAAG,CAAC,CAAC;wCAEhB,KAAK,CAAC,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,IAAI,EAAE,EAAE;4CAChC,IAAI,GAAG,GAAG,IAAI,CAAC,QAAQ,EAAE,CAAC;4CAC1B,IAAI,KAAK,GAAG,GAAG,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;4CAC3B,OAAO,IAAI,CAAC,CAAC;4CAEb,IAAI,OAAO,KAAK,CAAC,EAAE;gDAClB,MAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC,CAAC;gDACxB,MAAM,MAAM,GAAG,CAAC,SAAS,CAAC,CAAC;gDAC3B,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC,CAAC;6CAC1C;4CAED,IAAI,UAAU,GAAG,IAAI,CAAC;4CACpB,IAAI,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC,EAAC;gDAC7B,MAAM,QAAQ,GAAG,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;gDAC3C,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,oBAAoB,EAAE,QAAQ,CAAC,CAAC;gDACrE,IAAG,QAAQ,KAAK,CAAC,CAAC,EAAE;oDAClB,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,QAAQ,GAAG,CAAC,CAAC,CAAC,CAAC;oDACrC,MAAM,CAAC,MAAM,CAAC,sBAAsB,CAAC,qCAAqC,IAAI,EAAE,CAAC,CAAC;iDACnF;6CACF;wCACJ,CAAC,CAAC,CAAC;wCAEH,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,GAAG,EAAE,EAAE;4CACzB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;4CACjB,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC;wCACjB,CAAC,CAAC;wCAEF,qEAAqE;wCACrE,KAAK,CAAC,EAAE,CAAC,OAAO,EAAE,CAAC,IAAI,EAAE,EAAE;4CAC1B,OAAO,CAAC,GAAG,CAAC,kCAAkC,IAAI,EAAE,CAAC,CAAC;wCACvD,CAAC,CAAC,CAAC;qCACH;gCACF,CAAC,CAAC;6BACF,CAAC,sBAAsB;yBACxB;wBAAA,CAAC,CAAC,qBAAqB;oBACzB,CAAC,CAAC,CAAC,CAAC,iBAAiB;iBACrB,CAAC,2CAA2C;aAC7C,oCAAmC;QACrC,CAAC,CAAC,EAAC,iBAAiB;IACrB,CAAC,CAAC,CAAC,CAAC,kBAAkB;IAEtB,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IAEvC,IAAI,cAAc,GAAG,MAAM,CAAC,QAAQ,CAAC,eAAe,CAAC,0BAA0B,EAAE,GAAG,EAAE;QACrF,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,CAAC,kBAAkB,CAC7C,UAAU,EACV,OAAO,EACP,MAAM,CAAC,UAAU,CAAC,MAAM,EACxB;YACC,aAAa,EAAE,IAAI;YACnB,kBAAkB,EAAE,CAAC,MAAM,CAAC,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;SAC5D,CACD,CAAC;QAEF,wCAAwC;QACxC,KAAK,CAAC,OAAO,CAAC,IAAI,GAAG;;;;;;;;;0BASG,IAAI,IAAI,IAAI;;UAE5B;IACT,CAAC,CAAC,CAAC;IAEH,OAAO,CAAC,aAAa,CAAC,IAAI,CAAC,cAAc,CAAC,CAAC;AAC5C,CAAC;AAzMD,4BAyMC;AAED,SAAgB,UAAU;IACzB,6CAA6C;AAC9C,CAAC;AAFD,gCAEC;;;;;;;;;;;;AC3wBD,0C;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,kC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,+B;;;;;;;;;;;ACAA,iC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,gC;;;;;;;;;;;ACAA,mC;;;;;;;;;;;ACAA,iC","file":"extension.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/extension.ts\");\n","module.exports = require( './lib/connected-domain' );","/**\n * calculate all the connected domains based on the given two-dimensional array\n */\n\n/**\n * @param {Array} tdArray\n * @param {Function} indicator It receive the raw point data as the first parameter and decide what kind of domain the point belongs to, it should return a string as a domain identifier.\n * @param {Boolean} hardlink If use hard link. Default to false.\n * @return {Object} [{ bounding: { w: 12, h: 19, x: 0, y: 1 }, points: [ { x: 1, y: 2, point: {} } ], identifier: 'blue', domainId: 1 } ]\n */\nmodule.exports = function( tdArray, indicator, hardlink ){\n\n    hardlink = hardlink || false;\n\n    if( !tdArray ){\n        throw new Error( 'tdArray must be provided' );\n    }\n\n    if( !indicator ){\n        throw new Error( 'indicator must be provided' );\n    }\n\n    // clone 一份数据，因为需要对饮用进行修改，方便执行\n    tdArray = JSON.parse( JSON.stringify( tdArray ) );\n\n    // Result\n    var domains = {};\n    var domainUUID = 0;\n    var pointsHash = {};\n\n    // 遍历数组，划分domain\n\n    tdArray.forEach(function( row, y ){\n\n        row.forEach(function( colItem, x ){\n\n            // get the current point identifier.\n            var identifier = indicator( colItem, x, y );\n\n            // get neighbours\n            // Except for Undefined every data type is valid.\n            var neighbours = [];\n\n            // top neighbour\n            if( tdArray[ y - 1 ] && tdArray[ y - 1 ][ x ] !== undefined ){\n                neighbours.push( pointsHash[ x + '_' + ( y - 1 ) ] );\n            }\n\n            // left neighbour\n            if( row[ x - 1 ] !== undefined ){\n                neighbours.push( pointsHash[ ( x - 1 ) + '_' + y ] );\n            }\n\n            // soft link will treat corner link as domain link.\n            if( !hardlink ){\n                // top left neighbour\n                if( tdArray[ y - 1 ] && tdArray[ y - 1 ][ x - 1 ] !== undefined ){\n                    neighbours.push( pointsHash[ ( x - 1 ) + '_' + ( y - 1 ) ] );\n                }\n\n                // top right neighbour\n                if( tdArray[ y - 1 ] && tdArray[ y - 1 ][ x + 1 ] !== undefined ){\n                    neighbours.push( pointsHash[ ( x + 1 ) + '_' + ( y - 1 ) ] );\n                }\n            }\n\n            if( neighbours.length ){\n                var matched = false;\n\n                neighbours.forEach(function( neighbour ){\n\n                    if( neighbour.identifier == identifier ){\n\n                        // If the neighbour is the first neighbour has the same identifier\n                        if( !matched ){\n                            addPointToDomain( colItem, x, y, neighbour.domainId );\n                            matched = true;\n                        }\n\n                        // If more than one neighbour matched, check if these neighbours belong to the same domain\n                        // If not, merge these domains since they connects to each other.\n                        else {\n                            var colItemPoint = pointsHash[ x + '_' + y ];\n                            if( neighbour.domainId != colItemPoint.domainId ){\n                                mergeDomains( neighbour.domainId, colItemPoint.domainId );\n                            }\n                        }\n                    }\n                });\n\n                if( !matched ){\n                    addNewDomain( colItem, x, y, identifier );\n                }\n            }\n            else {\n                addNewDomain( colItem, x, y, identifier );\n            }\n        });\n    });\n\n    // some summary\n    var result = {\n        domains: [],\n        totalDomains: 0,\n        groupByIdentifier: {},\n        totalIdentifiers: 0\n    };\n\n    var domainId = null;\n    var identifier = null;\n    var domain = null;\n    for( domainId in domains ){\n        domain = domains[ domainId ];\n        domain.bounding = calculateBounding( domain.points );\n        identifier = domain.identifier;\n\n        result.domains.push( domain );\n        result.totalDomains++;\n\n        if( !( identifier in result.groupByIdentifier ) ){\n            result.groupByIdentifier[ identifier ] = [];\n            result.totalIdentifiers++;\n        }\n\n        result.groupByIdentifier[ identifier ].push( domain );\n    }\n\n\n    function calculateBounding( points ){\n\n        var minX = null;\n        var minY = null;\n        var maxX = null;\n        var maxY = null;\n\n        points.forEach(function( point ){\n\n            if( minX === null || point.x < minX ){\n                minX = point.x;\n            }\n\n            if( minY === null || point.y < minY ){\n                minY = point.y;\n            }\n\n            if( maxX === null || point.x > maxX ){\n                maxX = point.x;\n            }\n\n            if( maxY === null || point.y > maxY ){\n                maxY = point.y;\n            }\n        });\n\n        var w = maxX - minX;\n        var h = maxY - minY;\n\n        return {\n            x: minX,\n            y: minY,\n            w: w,\n            h: h\n        };\n    }\n\n    /**\n     *\n     * @param point\n     * @param x\n     * @param y\n     * @param identifier\n     */\n    function addNewDomain( point, x, y, identifier ){\n\n        var newDomain = {\n            identifier: identifier,\n            domainId: ++domainUUID,\n            bounding: {},\n            points: []\n        };\n\n        var newPoint = {\n            value: point,\n            x: x,\n            y: y,\n            identifier: identifier,\n            domainId: newDomain.domainId\n        };\n\n        pointsHash[ x + '_' + y ] = {\n            value: point,\n            identifier: identifier,\n            domainId: newDomain.domainId\n        };\n\n        newDomain.points.push( newPoint );\n\n        domains[ newDomain.domainId ] = newDomain;\n    }\n\n    /**\n     * add a point to a existing domain, and attach properties domainId and identifier to point.\n     * @param point\n     * @param x\n     * @param y\n     * @param domainId\n     */\n    function addPointToDomain( point, x, y, domainId ){\n\n        var domain = domains[ domainId ];\n        var newPoint = {\n            value: point,\n            x: x,\n            y: y,\n            identifier: domain.identifier,\n            domainId: domainId\n        };\n\n        pointsHash[ x + '_' + y ] = {\n            value: point,\n            identifier: domain.identifier,\n            domainId: domainId\n        };\n\n        domain.points.push( newPoint );\n    }\n\n    /**\n     * 将 domainB 合并到 domainA\n     * @param domainAId\n     * @param domainBId\n     */\n    function mergeDomains( domainAId, domainBId ){\n\n        var domainA = domains[ domainAId ];\n        var domainB = domains[ domainBId ];\n\n        if( domainA.identifier == domainB.identifier ){\n            // 更新 domainB 的domainId\n\n            domainB.domainId = domainA.domainId;\n\n            domainB.points.forEach(function( point ){\n                point.domainId = domainA.domainId;\n                pointsHash[ point.x + '_' + point.y ].domainId = domainA.domainId;\n            });\n\n            domainA.points = domainA.points.concat( domainB.points );\n\n            // 删除domainB\n            delete domains[ domainBId ];\n        }\n    }\n\n    return result;\n};","module.exports = require('./lib');\n","var ChildProcess = require('child_process');\nvar IS_WIN = process.platform === 'win32';\nvar TableParser = require('table-parser');\n/**\n * End of line.\n * Basically, the EOL should be:\n * - windows: \\r\\n\n * - *nix: \\n\n * But i'm trying to get every possibilities covered.\n */\nvar EOL = /(\\r\\n)|(\\n\\r)|\\n|\\r/;\nvar SystemEOL = require('os').EOL;\n\n/**\n * Execute child process\n * @type {Function}\n * @param {String[]} args\n * @param {Function} callback\n * @param {Object=null} callback.err\n * @param {Object[]} callback.stdout\n */\n\nvar Exec = module.exports = exports = function (args, callback) {\n  var spawn = ChildProcess.spawn;\n\n  // on windows, if use ChildProcess.exec(`wmic process get`), the stdout will gives you nothing\n  // that's why I use `cmd` instead\n  if (IS_WIN) {\n\n    var CMD = spawn('cmd');\n    var stdout = '';\n    var stderr = null;\n\n    CMD.stdout.on('data', function (data) {\n      stdout += data.toString();\n    });\n\n    CMD.stderr.on('data', function (data) {\n\n      if (stderr === null) {\n        stderr = data.toString();\n      }\n      else {\n        stderr += data.toString();\n      }\n    });\n\n    CMD.on('exit', function () {\n\n      var beginRow;\n      stdout = stdout.split(EOL);\n\n      // Find the line index for the titles\n      stdout.forEach(function (out, index) {\n        if (out && typeof beginRow == 'undefined' && out.indexOf('CommandLine') === 0) {\n          beginRow = index;\n        }\n      });\n\n      // get rid of the start (copyright) and the end (current pwd)\n      stdout.splice(stdout.length - 1, 1);\n      stdout.splice(0, beginRow);\n\n      callback(stderr, stdout.join(SystemEOL) || false);\n    });\n\n    CMD.stdin.write('wmic process get ProcessId,ParentProcessId,CommandLine \\n');\n    CMD.stdin.end();\n  }\n  else {\n    if (typeof args === 'string') {\n      args = args.split(/\\s+/);\n    }\n    const child = spawn('ps', args);\n    var stdout = '';\n    var stderr = null;\n\n    child.stdout.on('data', function (data) {\n      stdout += data.toString();\n    });\n\n    child.stderr.on('data', function (data) {\n\n      if (stderr === null) {\n        stderr = data.toString();\n      }\n      else {\n        stderr += data.toString();\n      }\n    });\n\n    child.on('exit', function () {\n      if (stderr) {\n        return callback(stderr.toString());\n      }\n      else {\n        callback(null, stdout || false);\n      }\n    });\n  }\n};\n\n/**\n * Query Process: Focus on pid & cmd\n * @param query\n * @param {String|String[]} query.pid\n * @param {String} query.command RegExp String\n * @param {String} query.arguments RegExp String\n * @param {String|array} query.psargs\n * @param {Function} callback\n * @param {Object=null} callback.err\n * @param {Object[]} callback.processList\n * @return {Object}\n */\n\nexports.lookup = function (query, callback) {\n\n  /**\n   * add 'lx' as default ps arguments, since the default ps output in linux like \"ubuntu\", wont include command arguments\n   */\n  var exeArgs = query.psargs || ['lx'];\n  var filter = {};\n  var idList;\n\n  // Lookup by PID\n  if (query.pid) {\n\n    if (Array.isArray(query.pid)) {\n      idList = query.pid;\n    }\n    else {\n      idList = [query.pid];\n    }\n\n    // Cast all PIDs as Strings\n    idList = idList.map(function (v) {\n      return String(v);\n    });\n\n  }\n\n\n  if (query.command) {\n    filter['command'] = new RegExp(query.command, 'i');\n  }\n\n  if (query.arguments) {\n    filter['arguments'] = new RegExp(query.arguments, 'i');\n  }\n\n  if (query.ppid) {\n    filter['ppid'] = new RegExp(query.ppid);\n  }\n\n  return Exec(exeArgs, function (err, output) {\n    if (err) {\n      return callback(err);\n    }\n    else {\n      var processList = parseGrid(output);\n      var resultList = [];\n\n      processList.forEach(function (p) {\n\n        var flt;\n        var type;\n        var result = true;\n\n        if (idList && idList.indexOf(String(p.pid)) < 0) {\n          return;\n        }\n\n        for (type in filter) {\n          flt = filter[type];\n          result = flt.test(p[type]) ? result : false;\n        }\n\n        if (result) {\n          resultList.push(p);\n        }\n      });\n\n      callback(null, resultList);\n    }\n  });\n};\n\n/**\n * Kill process\n * @param pid\n * @param {Object|String} signal\n * @param {String} signal.signal\n * @param {number} signal.timeout\n * @param next\n */\n\nexports.kill = function( pid, signal, next ){\n  //opts are optional\n  if(arguments.length == 2 && typeof signal == 'function'){\n    next = signal;\n    signal = undefined;\n  }\n\n  var checkTimeoutSeconds = (signal && signal.timeout) || 30;\n\n  if (typeof signal === 'object') {\n    signal = signal.signal;\n  }\n\n  try {\n    process.kill(pid, signal);\n  } catch(e) {\n    return next && next(e);\n  }\n\n  var checkConfident = 0;\n  var checkTimeoutTimer = null;\n  var checkIsTimeout = false;\n\n  function checkKilled(finishCallback) {\n    exports.lookup({ pid: pid }, function(err, list) {\n      if (checkIsTimeout) return;\n\n      if (err) {\n        clearTimeout(checkTimeoutTimer);\n        finishCallback && finishCallback(err);\n      } else if(list.length > 0) {\n        checkConfident = (checkConfident - 1) || 0;\n        checkKilled(finishCallback);\n      } else {\n        checkConfident++;\n        if (checkConfident === 5) {\n          clearTimeout(checkTimeoutTimer);\n          finishCallback && finishCallback();\n        } else {\n          checkKilled(finishCallback);\n        }\n      }\n    });\n  }\n\n  next && checkKilled(next);\n\n  checkTimeoutTimer = next && setTimeout(function() {\n    checkIsTimeout = true;\n    next(new Error('Kill process timeout'));\n  }, checkTimeoutSeconds * 1000);\n};\n\n/**\n * Parse the stdout into readable object.\n * @param {String} output\n */\n\nfunction parseGrid(output) {\n  if (!output) {\n    return [];\n  }\n  return formatOutput(TableParser.parse(output));\n}\n\n/**\n * format the structure, extract pid, command, arguments, ppid\n * @param data\n * @return {Array}\n */\n\nfunction formatOutput(data) {\n  var formatedData = [];\n  data.forEach(function (d) {\n    var pid = ( d.PID && d.PID[0] ) || ( d.ProcessId && d.ProcessId[0] ) || undefined;\n    var cmd = d.CMD || d.CommandLine || d.COMMAND || undefined;\n    var ppid = ( d.PPID && d.PPID[0] ) || ( d.ParentProcessId && d.ParentProcessId[0] ) || undefined;\n\n    if (pid && cmd) {\n      var command = cmd[0];\n      var args = '';\n\n      if (cmd.length > 1) {\n        args = cmd.slice(1);\n      }\n\n      formatedData.push({\n        pid: pid,\n        command: command,\n        arguments: args,\n        ppid: ppid\n      });\n    }\n  });\n\n  return formatedData;\n}\n","module.exports = require( './lib/index' );","/**\n *\n * 1, define the edge ( begin and end ) of every title field\n * 2, parse all the lines except the title line, get all the connected-domains\n * 3, group all the connected-domains vertically overlapped.\n * 4, a domain group belongs to a title field if they vertically overlapped\n * 5, calculate all the edge info through the group domain and title field relations.\n */\nvar ConnectedDomain = require('connected-domain');\nvar EMPTY_EX = /\\s/;\n\n/**\n * The output sting of cmd to parse\n * @param output\n * @returns {Array}\n */\nmodule.exports.parse = function (output) {\n\n  // Split into lines\n  // Basically, the EOL should be:\n  // - windows: \\r\\n\n  // - *nix: \\n\n  // But i'm trying to get every possibilities covered.\n  var linesTmp = output.split(/(\\r\\n)|(\\n\\r)|\\n|\\r/);\n\n  // valid lines\n  var lines = [];\n  // title field info, mapped with filed name.\n  var titleInfo = {};\n  // the two dimensional array of the lines\n  var twoDimArray = [];\n\n  // get rid of all the empty lines.\n  linesTmp.forEach(function (line) {\n    if (line && line.trim()) {\n      lines.push(line);\n    }\n  });\n\n  // build title fields edge info\n  // build two dimensional array for Connected-Domain to parse.\n  lines.forEach(function (line, index) {\n\n    // Treat the first line as the title fields line\n    if (index == 0) {\n      var fields = line.split(/\\s+/);\n\n      // record the beginning and ending for each field\n      fields.forEach(function (field, idx) {\n\n        if (field) {\n          var info = titleInfo[field] = {};\n          var indexBegin = line.indexOf(field);\n          var indexEnd = indexBegin + field.length;\n\n          if (idx == 0) {\n            info.titleBegin = 0;\n          }\n          else {\n            info.titleBegin = indexBegin;\n          }\n\n          if (idx == fields.length - 1) {\n            info.titleEnd = line.length - 1;\n          }\n          else {\n            info.titleEnd = indexEnd;\n          }\n        }\n      });\n    }\n    else {\n      twoDimArray[index - 1] = line.split('');\n    }\n  });\n\n  // In the connected-domain aspect of view, all the blanks are connected, and all the non-blanks are connected.\n  var connectedDomains = ConnectedDomain(twoDimArray, function (value) {\n    if (EMPTY_EX.test(value)) {\n      return -1;\n    }\n    else {\n      return 1;\n    }\n  }, true);\n\n  // all the connected domains grouped if they are vertically overlapped.\n  var valuesDomainsVerticalGroups = [];\n\n  // sore the domain list make 'x' in ascending order, it will prevent the situation that:\n  // 1, two domains are not overlapped, so two groups are created for them at first\n  // 2, another domain is found overlapped with both of the domains at the first step.\n  // 3, In this situation the three groups have to be merged, which is complicated to implement.\n  //\n  // If the list is sorted in this order, this situation can't happen, because:\n  // - 1, If two non-overlapped domains A, B ( the \"x\" value of A less than B ) are found first.\n  // - 2, Since the list is in 'x' ascending order, the 'x' values of the following domains must larger or equal to the \"x\" of B, which means they will never overlapped with domain A.\n  // - 3, So this situation can't happen.\n  connectedDomains.domains.sort(function (a, b) {\n    return a.bounding.x - b.bounding.x;\n  });\n\n  // Group domains vertically overlapped.\n  connectedDomains.domains.forEach(function (domain) {\n    // only handle un-empty domain\n    if (domain.identifier === 1) {\n      var overlapped = false;\n\n      // If overlapped\n      valuesDomainsVerticalGroups.forEach(function (group) {\n        var bounding = domain.bounding;\n        var left = bounding.x;\n        var right = bounding.x + bounding.w;\n\n        if (overlap(left, right, group.begin, group.end)) {\n\n          overlapped = true;\n          group.domains.push(domain);\n          group.begin = group.begin > left ? left : group.begin;\n          group.end = group.end < right ? right : group.end;\n        }\n      });\n\n      // If not overlapped with any group, then create a new group\n      if (!overlapped) {\n        valuesDomainsVerticalGroups.push({\n          begin: domain.bounding.x,\n          end: domain.bounding.x + domain.bounding.w,\n          domains: [domain]\n        });\n      }\n    }\n  });\n\n  // connect all the groups to the title fields\n  valuesDomainsVerticalGroups.forEach(function (group) {\n    var title = null;\n    var info = null;\n    var overlapped = false;\n\n    var minimunLeftDistance = null;\n    var nearestLeftTitle = null;\n    var distance = null;\n\n    for (title in titleInfo) {\n      info = titleInfo[title];\n\n      /**\n       * The calculation below is to find the nearest left title field to the group, in case no overlapped title field found.\n       */\n      if (group.begin > info.titleBegin) {\n        distance = group.begin - info.titleBegin;\n\n        if (!nearestLeftTitle || ( distance < minimunLeftDistance )) {\n          nearestLeftTitle = title;\n          minimunLeftDistance = distance;\n        }\n      }\n\n      if (overlap(group.begin, group.end, info.titleBegin, info.titleEnd)) {\n\n        overlapped = true;\n        info.titleBegin = info.titleBegin > group.begin ? group.begin : info.titleBegin;\n        info.titleEnd = info.titleEnd < group.end ? group.end : info.titleEnd;\n      }\n    }\n\n    // Groups not match any title field belongs to the nearest left title field\n    if (!overlapped && nearestLeftTitle) {\n      var nearestTitleField = titleInfo[nearestLeftTitle];\n      nearestTitleField.titleBegin = nearestTitleField.titleBegin > group.begin ? group.begin : nearestTitleField.titleBegin;\n      nearestTitleField.titleEnd = nearestTitleField.titleEnd < group.end ? group.end : nearestTitleField.titleEnd;\n\n    }\n  });\n\n  // The final result\n  var result = [];\n\n  // Since we have got all the title bounding edges, we can split all the lines into values now\n  lines.forEach(function (line, index) {\n    // skip the first line\n    if (index > 0) {\n\n      var lineItem = {};\n      var title = null;\n      var info = null;\n      var value = null;\n      for (title in titleInfo) {\n        info = titleInfo[title];\n        value = line.substring(info.titleBegin, info.titleEnd + 1);\n        lineItem[title] = splitValue(value.trim());\n      }\n\n      result.push(lineItem);\n    }\n  });\n\n  return result;\n};\n\n/**\n * Test if two bounding overlapped vertically\n * @param begin1\n * @param end1\n * @param begin2\n * @param end2\n * @returns {boolean}\n */\nfunction overlap(begin1, end1, begin2, end2) {\n  return ( begin1 > begin2 && begin1 < end2 ) || // 2--1--2--1 or 2--1--1--2\n    ( end1 > begin2 && end1 < end2 ) ||     // 1--2--1--2 or 2--1--1--2\n    ( begin1 <= begin2 && end1 >= end2 );// 21--12 or 1--2--2--1\n}\n\n/**\n * transform a string value into array. It's not just split(), but also to consider some chunk that wrapped with `\"`, like below:\n *      \"C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe\" --type=renderer --lang=zh-CN, `C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe` should be treated as a whole,\n *      also, be careful don't be mislead by format like `--name=\"neekey\"`, even more complicated: `--name=\"Neekey Ni\"`\n * so, `\"C:\\Program Files\\Internet Explorer\\iexplore.exe\" --name=\"Jack Neekey\"` should split into:\n *  - C:\\Program Files\\Internet Explorer\\iexplore.exe  // without `\"`\n *  - --name=\"Jack Neekey\"                             // with `\"`\n */\nfunction splitValue(value) {\n\n  var match = value.match(/\"/g);\n\n  // If only one \" found, then just ignore it\n  if (!match || match.length == 1) {\n    return value.split(/\\s+/);\n  }\n  else {\n    var result = [];\n    var chunk = null;\n    var ifInWrappedChunk = false;\n    var ifInPureWrappedChunk = false;\n    var quotaCount = 0;\n\n    // If the match length is a even, than nothing special, if a odd, ignore the last one.\n    var maxQuotaCount = match.length % 2 == 0 ? match.length : match.length - 1;\n\n    var previousItem = null;\n    var values = value.split('');\n\n    values.forEach(function (item, index) {\n\n      if (item !== ' ') {\n\n        if (item === '\"') {\n          // quota chunk begin\n          if (ifInWrappedChunk === false && quotaCount <= maxQuotaCount) {\n            ifInWrappedChunk = true;\n            quotaCount++;\n\n            // pure quota chunk begin\n            if (previousItem === ' ' || previousItem === null) {\n              ifInPureWrappedChunk = true;\n              chunk = '';\n            }\n            // normal continue\n            else {\n              chunk += item;\n            }\n          }\n          // quota chunk end\n          else if (ifInWrappedChunk === true) {\n            ifInWrappedChunk = false;\n            quotaCount++;\n\n            // pure quota chunk end\n            if (ifInPureWrappedChunk === true) {\n              ifInPureWrappedChunk = false;\n              result.push(chunk);\n              chunk = null;\n            }\n            // normal continue\n            else {\n              chunk += item;\n            }\n          }\n        }\n        // normal begin\n        else if (ifInWrappedChunk === false && ( previousItem === ' ' || previousItem === null )) {\n          chunk = item;\n        }\n        // normal or quota chunk continue.\n        else {\n          chunk += item;\n        }\n      }\n      // quota chunk continue, in quota chunk, blank is valid.\n      else if (ifInWrappedChunk) {\n        chunk += item;\n      }\n      // if not in quota chunk, them a blank means an end. But make sure chunk is exist, cause that could be blanks at the beginning.\n      else if (chunk !== null) {\n        result.push(chunk);\n        chunk = null;\n      }\n\n      previousItem = item;\n\n      // If this is the last one, but chunk is not end\n      if (index == ( values.length - 1 ) && chunk !== null) {\n        result.push(chunk);\n        chunk = null;\n      }\n    });\n\n    return result;\n  }\n}\n","'use strict';\n\nconst WebSocket = require('./lib/websocket');\n\nWebSocket.createWebSocketStream = require('./lib/stream');\nWebSocket.Server = require('./lib/websocket-server');\nWebSocket.Receiver = require('./lib/receiver');\nWebSocket.Sender = require('./lib/sender');\n\nmodule.exports = WebSocket;\n","'use strict';\n\nconst { EMPTY_BUFFER } = require('./constants');\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) return target.slice(0, offset);\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  // Required until https://github.com/nodejs/node/issues/9006 is resolved.\n  const length = buffer.length;\n  for (let i = 0; i < length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.byteLength === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = Buffer.from(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = viewToBuffer(data);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\n/**\n * Converts an `ArrayBuffer` view into a buffer.\n *\n * @param {(DataView|TypedArray)} view The view to convert\n * @return {Buffer} Converted view\n * @private\n */\nfunction viewToBuffer(view) {\n  const buf = Buffer.from(view.buffer);\n\n  if (view.byteLength !== view.buffer.byteLength) {\n    return buf.slice(view.byteOffset, view.byteOffset + view.byteLength);\n  }\n\n  return buf;\n}\n\ntry {\n  const bufferUtil = require('bufferutil');\n  const bu = bufferUtil.BufferUtil || bufferUtil;\n\n  module.exports = {\n    concat,\n    mask(source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bu.mask(source, mask, output, offset, length);\n    },\n    toArrayBuffer,\n    toBuffer,\n    unmask(buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bu.unmask(buffer, mask);\n    }\n  };\n} catch (e) /* istanbul ignore next */ {\n  module.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n  };\n}\n","'use strict';\n\nmodule.exports = {\n  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  EMPTY_BUFFER: Buffer.alloc(0),\n  NOOP: () => {}\n};\n","'use strict';\n\n/**\n * Class representing an event.\n *\n * @private\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} target A reference to the target to which the event was dispatched\n   */\n  constructor(type, target) {\n    this.target = target;\n    this.type = type;\n  }\n}\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n * @private\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The received data\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(data, target) {\n    super('message', target);\n\n    this.data = data;\n  }\n}\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n * @private\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {Number} code The status code explaining why the connection is being closed\n   * @param {String} reason A human-readable string explaining why the connection is closing\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(code, reason, target) {\n    super('close', target);\n\n    this.wasClean = target._closeFrameReceived && target._closeFrameSent;\n    this.reason = reason;\n    this.code = code;\n  }\n}\n\n/**\n * Class representing an open event.\n *\n * @extends Event\n * @private\n */\nclass OpenEvent extends Event {\n  /**\n   * Create a new `OpenEvent`.\n   *\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(target) {\n    super('open', target);\n  }\n}\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n * @private\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {Object} error The error that generated this event\n   * @param {WebSocket} target A reference to the target to which the event was dispatched\n   */\n  constructor(error, target) {\n    super('error', target);\n\n    this.message = error.message;\n    this.error = error;\n  }\n}\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} method A string representing the event type to listen for\n   * @param {Function} listener The listener to add\n   * @public\n   */\n  addEventListener(method, listener) {\n    if (typeof listener !== 'function') return;\n\n    function onMessage(data) {\n      listener.call(this, new MessageEvent(data, this));\n    }\n\n    function onClose(code, message) {\n      listener.call(this, new CloseEvent(code, message, this));\n    }\n\n    function onError(error) {\n      listener.call(this, new ErrorEvent(error, this));\n    }\n\n    function onOpen() {\n      listener.call(this, new OpenEvent(this));\n    }\n\n    if (method === 'message') {\n      onMessage._listener = listener;\n      this.on(method, onMessage);\n    } else if (method === 'close') {\n      onClose._listener = listener;\n      this.on(method, onClose);\n    } else if (method === 'error') {\n      onError._listener = listener;\n      this.on(method, onError);\n    } else if (method === 'open') {\n      onOpen._listener = listener;\n      this.on(method, onOpen);\n    } else {\n      this.on(method, listener);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} method A string representing the event type to remove\n   * @param {Function} listener The listener to remove\n   * @public\n   */\n  removeEventListener(method, listener) {\n    const listeners = this.listeners(method);\n\n    for (let i = 0; i < listeners.length; i++) {\n      if (listeners[i] === listener || listeners[i]._listener === listener) {\n        this.removeListener(method, listeners[i]);\n      }\n    }\n  }\n};\n\nmodule.exports = EventTarget;\n","'use strict';\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n\n  if (header === undefined || header === '') return offers;\n\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 /* ' ' */ || code === 0x09 /* '\\t' */) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n","'use strict';\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} concurrency The maximum number of jobs allowed to run\n   *     concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n","'use strict';\n\nconst zlib = require('zlib');\n\nconst bufferUtil = require('./buffer-util');\nconst Limiter = require('./limiter');\nconst { kStatusCode, NOOP } = require('./constants');\n\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} options.serverNoContextTakeover Request/accept disabling\n   *     of server context takeover\n   * @param {Boolean} options.clientNoContextTakeover Advertise/acknowledge\n   *     disabling of client context takeover\n   * @param {(Boolean|Number)} options.serverMaxWindowBits Request/confirm the\n   *     use of a custom server window size\n   * @param {(Boolean|Number)} options.clientMaxWindowBits Advertise support\n   *     for, or request, a custom client window size\n   * @param {Object} options.zlibDeflateOptions Options to pass to zlib on deflate\n   * @param {Object} options.zlibInflateOptions Options to pass to zlib on inflate\n   * @param {Number} options.threshold Size (in bytes) below which messages\n   *     should not be compressed\n   * @param {Number} options.concurrencyLimit The number of concurrent calls to\n   *     zlib\n   * @param {Boolean} isServer Create the instance in either server or client\n   *     mode\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      if (this._deflate[kCallback]) {\n        this._deflate[kCallback]();\n      }\n\n      this._deflate.close();\n      this._deflate = null;\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        if (err || result) {\n          callback(err, result);\n        }\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {Buffer} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      //\n      // An `'error'` event is emitted, only on Node.js < 10.0.0, if the\n      // `zlib.DeflateRaw` instance is closed while data is being processed.\n      // This can happen if `PerMessageDeflate#cleanup()` is called at the wrong\n      // time due to an abnormal WebSocket closure.\n      //\n      this._deflate.on('error', NOOP);\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // This `if` statement is only needed for Node.js < 10.0.0 because as of\n        // commit https://github.com/nodejs/node/commit/5e3f5164, the flush\n        // callback is no longer called if the deflate stream is closed while\n        // data is being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) data = data.slice(0, data.length - 4);\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.close();\n        this._deflate = null;\n      } else {\n        this._deflate[kTotalLength] = 0;\n        this._deflate[kBuffers] = [];\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n","'use strict';\n\nconst { Writable } = require('stream');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = require('./constants');\nconst { concat, toArrayBuffer, unmask } = require('./buffer-util');\nconst { isValidStatusCode, isValidUTF8 } = require('./validation');\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends stream.Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {String} binaryType The type for binary data\n   * @param {Object} extensions An object containing the negotiated extensions\n   * @param {Number} maxPayload The maximum allowed message length\n   */\n  constructor(binaryType, extensions, maxPayload) {\n    super();\n\n    this._binaryType = binaryType || BINARY_TYPES[0];\n    this[kWebSocket] = undefined;\n    this._extensions = extensions || {};\n    this._maxPayload = maxPayload | 0;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._state = GET_INFO;\n    this._loop = false;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = buf.slice(n);\n      return buf.slice(0, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = buf.slice(n);\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    let err;\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          err = this.getInfo();\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          err = this.getPayloadLength16();\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          err = this.getPayloadLength64();\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          err = this.getData(cb);\n          break;\n        default:\n          // `INFLATING`\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    cb(err);\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getInfo() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      this._loop = false;\n      return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002);\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      this._loop = false;\n      return error(RangeError, 'RSV1 must be clear', true, 1002);\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (!this._fragmented) {\n        this._loop = false;\n        return error(RangeError, 'invalid opcode 0', true, 1002);\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        this._loop = false;\n        return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        this._loop = false;\n        return error(RangeError, 'FIN must be set', true, 1002);\n      }\n\n      if (compressed) {\n        this._loop = false;\n        return error(RangeError, 'RSV1 must be clear', true, 1002);\n      }\n\n      if (this._payloadLength > 0x7d) {\n        this._loop = false;\n        return error(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002\n        );\n      }\n    } else {\n      this._loop = false;\n      return error(RangeError, `invalid opcode ${this._opcode}`, true, 1002);\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength16() {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    return this.haveLength();\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  getPayloadLength64() {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      this._loop = false;\n      return error(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009\n      );\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    return this.haveLength();\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @return {(RangeError|undefined)} A possible error\n   * @private\n   */\n  haveLength() {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        this._loop = false;\n        return error(RangeError, 'Max payload size exceeded', false, 1009);\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n      if (this._masked) unmask(data, this._mask);\n    }\n\n    if (this._opcode > 0x07) return this.controlMessage(data);\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its lenght is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    return this.dataMessage();\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          return cb(\n            error(RangeError, 'Max payload size exceeded', false, 1009)\n          );\n        }\n\n        this._fragments.push(buf);\n      }\n\n      const er = this.dataMessage();\n      if (er) return cb(er);\n\n      this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @return {(Error|undefined)} A possible error\n   * @private\n   */\n  dataMessage() {\n    if (this._fin) {\n      const messageLength = this._messageLength;\n      const fragments = this._fragments;\n\n      this._totalPayloadLength = 0;\n      this._messageLength = 0;\n      this._fragmented = 0;\n      this._fragments = [];\n\n      if (this._opcode === 2) {\n        let data;\n\n        if (this._binaryType === 'nodebuffer') {\n          data = concat(fragments, messageLength);\n        } else if (this._binaryType === 'arraybuffer') {\n          data = toArrayBuffer(concat(fragments, messageLength));\n        } else {\n          data = fragments;\n        }\n\n        this.emit('message', data);\n      } else {\n        const buf = concat(fragments, messageLength);\n\n        if (!isValidUTF8(buf)) {\n          this._loop = false;\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('message', buf.toString());\n      }\n    }\n\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data) {\n    if (this._opcode === 0x08) {\n      this._loop = false;\n\n      if (data.length === 0) {\n        this.emit('conclude', 1005, '');\n        this.end();\n      } else if (data.length === 1) {\n        return error(RangeError, 'invalid payload length 1', true, 1002);\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          return error(RangeError, `invalid status code ${code}`, true, 1002);\n        }\n\n        const buf = data.slice(2);\n\n        if (!isValidUTF8(buf)) {\n          return error(Error, 'invalid UTF-8 sequence', true, 1007);\n        }\n\n        this.emit('conclude', code, buf.toString());\n        this.end();\n      }\n    } else if (this._opcode === 0x09) {\n      this.emit('ping', data);\n    } else {\n      this.emit('pong', data);\n    }\n\n    this._state = GET_INFO;\n  }\n}\n\nmodule.exports = Receiver;\n\n/**\n * Builds an error object.\n *\n * @param {(Error|RangeError)} ErrorCtor The error constructor\n * @param {String} message The error message\n * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n *     `message`\n * @param {Number} statusCode The status code\n * @return {(Error|RangeError)} The error\n * @private\n */\nfunction error(ErrorCtor, message, prefix, statusCode) {\n  const err = new ErrorCtor(\n    prefix ? `Invalid WebSocket frame: ${message}` : message\n  );\n\n  Error.captureStackTrace(err, error);\n  err[kStatusCode] = statusCode;\n  return err;\n}\n","'use strict';\n\nconst { randomFillSync } = require('crypto');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst { EMPTY_BUFFER } = require('./constants');\nconst { isValidStatusCode } = require('./validation');\nconst { mask: applyMask, toBuffer } = require('./buffer-util');\n\nconst mask = Buffer.alloc(4);\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {net.Socket} socket The connection socket\n   * @param {Object} extensions An object containing the negotiated extensions\n   */\n  constructor(socket, extensions) {\n    this._extensions = extensions || {};\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._deflating = false;\n    this._queue = [];\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {Buffer} data The data to frame\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @return {Buffer[]} The framed data as a list of `Buffer` instances\n   * @public\n   */\n  static frame(data, options) {\n    const merge = options.mask && options.readOnly;\n    let offset = options.mask ? 6 : 2;\n    let payloadLength = data.length;\n\n    if (data.length >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (data.length > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? data.length + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(data.length, 2);\n    } else if (payloadLength === 127) {\n      target.writeUInt32BE(0, 2);\n      target.writeUInt32BE(data.length, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    randomFillSync(mask, 0, 4);\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, data.length);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, data.length);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {(Number|undefined)} code The status code component of the body\n   * @param {String} data The message component of the body\n   * @param {Boolean} mask Specifies whether or not to mask the message\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || data === '') {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      buf = Buffer.allocUnsafe(2 + Buffer.byteLength(data));\n      buf.writeUInt16BE(code, 0);\n      buf.write(data, 2);\n    }\n\n    if (this._deflating) {\n      this.enqueue([this.doClose, buf, mask, cb]);\n    } else {\n      this.doClose(buf, mask, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a close message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @private\n   */\n  doClose(data, mask, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x08,\n        mask,\n        readOnly: false\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPing(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a ping message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPing(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x09,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    const buf = toBuffer(data);\n\n    if (this._deflating) {\n      this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);\n    } else {\n      this.doPong(buf, mask, toBuffer.readOnly, cb);\n    }\n  }\n\n  /**\n   * Frames and sends a pong message.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} mask Specifies whether or not to mask `data`\n   * @param {Boolean} readOnly Specifies whether `data` can be modified\n   * @param {Function} cb Callback\n   * @private\n   */\n  doPong(data, mask, readOnly, cb) {\n    this.sendFrame(\n      Sender.frame(data, {\n        fin: true,\n        rsv1: false,\n        opcode: 0x0a,\n        mask,\n        readOnly\n      }),\n      cb\n    );\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const buf = toBuffer(data);\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (rsv1 && perMessageDeflate) {\n        rsv1 = buf.length >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    if (perMessageDeflate) {\n      const opts = {\n        fin: options.fin,\n        rsv1,\n        opcode,\n        mask: options.mask,\n        readOnly: toBuffer.readOnly\n      };\n\n      if (this._deflating) {\n        this.enqueue([this.dispatch, buf, this._compress, opts, cb]);\n      } else {\n        this.dispatch(buf, this._compress, opts, cb);\n      }\n    } else {\n      this.sendFrame(\n        Sender.frame(buf, {\n          fin: options.fin,\n          rsv1: false,\n          opcode,\n          mask: options.mask,\n          readOnly: toBuffer.readOnly\n        }),\n        cb\n      );\n    }\n  }\n\n  /**\n   * Dispatches a data message.\n   *\n   * @param {Buffer} data The message to send\n   * @param {Boolean} compress Specifies whether or not to compress `data`\n   * @param {Object} options Options object\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} options.readOnly Specifies whether `data` can be modified\n   * @param {Boolean} options.fin Specifies whether or not to set the FIN bit\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Boolean} options.rsv1 Specifies whether or not to set the RSV1 bit\n   * @param {Function} cb Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._deflating = true;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      this._deflating = false;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (!this._deflating && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[1].length;\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[1].length;\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {Buffer[]} list The frame to send\n   * @param {Function} cb Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n","'use strict';\n\nconst { Duplex } = require('stream');\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {stream.Duplex} The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} options The options for the `Duplex` constructor\n * @return {stream.Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let resumeOnReceiverDrain = true;\n\n  function receiverOnDrain() {\n    if (resumeOnReceiverDrain) ws._socket.resume();\n  }\n\n  if (ws.readyState === ws.CONNECTING) {\n    ws.once('open', function open() {\n      ws._receiver.removeAllListeners('drain');\n      ws._receiver.on('drain', receiverOnDrain);\n    });\n  } else {\n    ws._receiver.removeAllListeners('drain');\n    ws._receiver.on('drain', receiverOnDrain);\n  }\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg) {\n    if (!duplex.push(msg)) {\n      resumeOnReceiverDrain = false;\n      ws._socket.pause();\n    }\n  });\n\n  ws.once('error', function error(err) {\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function(err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    ws.once('close', function close() {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n    ws.terminate();\n  };\n\n  duplex._final = function(callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    if (ws._socket._writableState.finished) {\n      if (duplex._readableState.endEmitted) duplex.destroy();\n      callback();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the WebSocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function() {\n    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {\n      resumeOnReceiverDrain = true;\n      if (!ws._receiver._writableState.needDrain) ws._socket.resume();\n    }\n  };\n\n  duplex._write = function(chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n","'use strict';\n\ntry {\n  const isValidUTF8 = require('utf-8-validate');\n\n  exports.isValidUTF8 =\n    typeof isValidUTF8 === 'object'\n      ? isValidUTF8.Validation.isValidUTF8 // utf-8-validate@<3.0.0\n      : isValidUTF8;\n} catch (e) /* istanbul ignore next */ {\n  exports.isValidUTF8 = () => true;\n}\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nexports.isValidStatusCode = (code) => {\n  return (\n    (code >= 1000 &&\n      code <= 1013 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n};\n","'use strict';\n\nconst EventEmitter = require('events');\nconst { createHash } = require('crypto');\nconst { createServer, STATUS_CODES } = require('http');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst WebSocket = require('./websocket');\nconst { format, parse } = require('./extension');\nconst { GUID } = require('./constants');\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst kUsedByWebSocketServer = Symbol('kUsedByWebSocketServer');\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Number} options.backlog The maximum length of the queue of pending\n   *     connections\n   * @param {Boolean} options.clientTracking Specifies whether or not to track\n   *     clients\n   * @param {Function} options.handleProtocols A hook to handle protocols\n   * @param {String} options.host The hostname where to bind the server\n   * @param {Number} options.maxPayload The maximum allowed message size\n   * @param {Boolean} options.noServer Enable no server mode\n   * @param {String} options.path Accept only connections matching this path\n   * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n   *     permessage-deflate\n   * @param {Number} options.port The port where to bind the server\n   * @param {http.Server} options.server A pre-created HTTP/S server to use\n   * @param {Function} options.verifyClient A hook to reject connections\n   * @param {Function} callback A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      maxPayload: 100 * 1024 * 1024,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      ...options\n    };\n\n    if (options.port == null && !options.server && !options.noServer) {\n      throw new TypeError(\n        'One of the \"port\", \"server\", or \"noServer\" options must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = createServer((req, res) => {\n        const body = STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      if (options.server[kUsedByWebSocketServer]) {\n        throw new Error(\n          'The HTTP/S server is already being used by another WebSocket server'\n        );\n      }\n\n      options.server[kUsedByWebSocketServer] = true;\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, (ws) => {\n            this.emit('connection', ws, req);\n          });\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) this.clients = new Set();\n    this.options = options;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Close the server.\n   *\n   * @param {Function} cb Callback\n   * @public\n   */\n  close(cb) {\n    if (cb) this.once('close', cb);\n\n    //\n    // Terminate all associated clients.\n    //\n    if (this.clients) {\n      for (const client of this.clients) client.terminate();\n    }\n\n    const server = this._server;\n\n    if (server) {\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // Close the http server if it was internally created.\n      //\n      if (this.options.port != null) {\n        server.close(() => this.emit('close'));\n        return;\n      }\n\n      delete server[kUsedByWebSocketServer];\n    }\n\n    process.nextTick(emitClose, this);\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key =\n      req.headers['sec-websocket-key'] !== undefined\n        ? req.headers['sec-websocket-key'].trim()\n        : false;\n    const version = +req.headers['sec-websocket-version'];\n    const extensions = {};\n\n    if (\n      req.method !== 'GET' ||\n      req.headers.upgrade.toLowerCase() !== 'websocket' ||\n      !key ||\n      !keyRegex.test(key) ||\n      (version !== 8 && version !== 13) ||\n      !this.shouldHandle(req)\n    ) {\n      return abortHandshake(socket, 400);\n    }\n\n    if (this.options.perMessageDeflate) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = parse(req.headers['sec-websocket-extensions']);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        return abortHandshake(socket, 400);\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.connection.authorized || req.connection.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(key, extensions, req, socket, head, cb);\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(key, extensions, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Object} extensions The accepted extensions\n   * @param {http.IncomingMessage} req The request object\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @private\n   */\n  completeUpgrade(key, extensions, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new WebSocket(null);\n    let protocol = req.headers['sec-websocket-protocol'];\n\n    if (protocol) {\n      protocol = protocol.trim().split(/ *, */);\n\n      //\n      // Optionally call external protocol selection handler.\n      //\n      if (this.options.handleProtocols) {\n        protocol = this.options.handleProtocols(protocol, req);\n      } else {\n        protocol = protocol[0];\n      }\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws.protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, this.options.maxPayload);\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => this.clients.delete(ws));\n    }\n\n    cb(ws);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server.emit('close');\n}\n\n/**\n * Handle premature socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {net.Socket} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    message = message || STATUS_CODES[code];\n    headers = {\n      Connection: 'close',\n      'Content-type': 'text/html',\n      'Content-Length': Buffer.byteLength(message),\n      ...headers\n    };\n\n    socket.write(\n      `HTTP/1.1 ${code} ${STATUS_CODES[code]}\\r\\n` +\n        Object.keys(headers)\n          .map((h) => `${h}: ${headers[h]}`)\n          .join('\\r\\n') +\n        '\\r\\n\\r\\n' +\n        message\n    );\n  }\n\n  socket.removeListener('error', socketOnError);\n  socket.destroy();\n}\n","'use strict';\n\nconst EventEmitter = require('events');\nconst https = require('https');\nconst http = require('http');\nconst net = require('net');\nconst tls = require('tls');\nconst { randomBytes, createHash } = require('crypto');\nconst { URL } = require('url');\n\nconst PerMessageDeflate = require('./permessage-deflate');\nconst Receiver = require('./receiver');\nconst Sender = require('./sender');\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = require('./constants');\nconst { addEventListener, removeEventListener } = require('./event-target');\nconst { format, parse } = require('./extension');\nconst { toBuffer } = require('./buffer-util');\n\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst protocolVersions = [8, 13];\nconst closeTimeout = 30 * 1000;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|url.URL)} address The URL to which to connect\n   * @param {(String|String[])} protocols The subprotocols\n   * @param {Object} options Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this.readyState = WebSocket.CONNECTING;\n    this.protocol = '';\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = '';\n    this._closeTimer = null;\n    this._closeCode = 1006;\n    this._extensions = {};\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (Array.isArray(protocols)) {\n        protocols = protocols.join(', ');\n      } else if (typeof protocols === 'object' && protocols !== null) {\n        options = protocols;\n        protocols = undefined;\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._isServer = true;\n    }\n  }\n\n  get CONNECTING() {\n    return WebSocket.CONNECTING;\n  }\n  get CLOSING() {\n    return WebSocket.CLOSING;\n  }\n  get CLOSED() {\n    return WebSocket.CLOSED;\n  }\n  get OPEN() {\n    return WebSocket.OPEN;\n  }\n\n  /**\n   * This deviates from the WHATWG interface since ws doesn't support the\n   * required default \"blob\" type (instead we define a custom \"nodebuffer\"\n   * type).\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    //\n    // `socket.bufferSize` is `undefined` if the socket is closed.\n    //\n    return (this._socket.bufferSize || 0) + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {net.Socket} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Number} maxPayload The maximum allowed message size\n   * @private\n   */\n  setSocket(socket, head, maxPayload) {\n    const receiver = new Receiver(\n      this._binaryType,\n      this._extensions,\n      maxPayload\n    );\n\n    this._sender = new Sender(socket, this._extensions);\n    this._receiver = receiver;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    socket.setTimeout(0);\n    socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this.readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    this.readyState = WebSocket.CLOSED;\n\n    if (!this._socket) {\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} code Status code explaining why the connection is closing\n   * @param {String} data A string explaining why the connection is closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (this._closeFrameSent && this._closeFrameReceived) this._socket.end();\n      return;\n    }\n\n    this.readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n      if (this._closeFrameReceived) this._socket.end();\n    });\n\n    //\n    // Specify a timeout for the closing handshake to complete.\n    //\n    this._closeTimer = setTimeout(\n      this._socket.destroy.bind(this._socket),\n      closeTimeout\n    );\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} data The data to send\n   * @param {Boolean} mask Indicates whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} options.compress Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} options.binary Specifies whether `data` is binary or text\n   * @param {Boolean} options.fin Specifies whether the fragment is the last one\n   * @param {Boolean} options.mask Specifies whether or not to mask `data`\n   * @param {Function} cb Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      return abortHandshake(this, this._req, msg);\n    }\n\n    if (this._socket) {\n      this.readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\nreadyStates.forEach((readyState, i) => {\n  WebSocket[readyState] = i;\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    /**\n     * Return the listener of the event.\n     *\n     * @return {(Function|undefined)} The event listener or `undefined`\n     * @public\n     */\n    get() {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        if (listeners[i]._listener) return listeners[i]._listener;\n      }\n\n      return undefined;\n    },\n    /**\n     * Add a listener for the event.\n     *\n     * @param {Function} listener The listener to add\n     * @public\n     */\n    set(listener) {\n      const listeners = this.listeners(method);\n      for (let i = 0; i < listeners.length; i++) {\n        //\n        // Remove only the listeners added via `addEventListener`.\n        //\n        if (listeners[i]._listener) this.removeListener(method, listeners[i]);\n      }\n      this.addEventListener(method, listener);\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|url.URL)} address The URL to which to connect\n * @param {String} protocols The subprotocols\n * @param {Object} options Connection options\n * @param {(Boolean|Object)} options.perMessageDeflate Enable/disable\n *     permessage-deflate\n * @param {Number} options.handshakeTimeout Timeout in milliseconds for the\n *     handshake request\n * @param {Number} options.protocolVersion Value of the `Sec-WebSocket-Version`\n *     header\n * @param {String} options.origin Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {Number} options.maxPayload The maximum allowed message size\n * @param {Boolean} options.followRedirects Whether or not to follow redirects\n * @param {Number} options.maxRedirects The maximum number of redirects allowed\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    createConnection: undefined,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: undefined,\n    auth: undefined,\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n    websocket.url = address.href;\n  } else {\n    parsedUrl = new URL(address);\n    websocket.url = address;\n  }\n\n  const isUnixSocket = parsedUrl.protocol === 'ws+unix:';\n\n  if (!parsedUrl.host && (!isUnixSocket || !parsedUrl.pathname)) {\n    throw new Error(`Invalid URL: ${websocket.url}`);\n  }\n\n  const isSecure =\n    parsedUrl.protocol === 'wss:' || parsedUrl.protocol === 'https:';\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const get = isSecure ? https.get : http.get;\n  let perMessageDeflate;\n\n  opts.createConnection = isSecure ? tlsConnect : netConnect;\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket',\n    ...opts.headers\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols) {\n    opts.headers['Sec-WebSocket-Protocol'] = protocols;\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isUnixSocket) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req = (websocket._req = get(opts));\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (websocket._req.aborted) return;\n\n    req = websocket._req = null;\n    websocket.readyState = WebSocket.CLOSING;\n    websocket.emit('error', err);\n    websocket.emitClose();\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      const addr = new URL(location, address);\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the `upgrade`\n    // event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    const protList = (protocols || '').split(/, */);\n    let protError;\n\n    if (!protocols && serverProt) {\n      protError = 'Server sent a subprotocol but none was requested';\n    } else if (protocols && !serverProt) {\n      protError = 'Server sent no subprotocol';\n    } else if (serverProt && !protList.includes(serverProt)) {\n      protError = 'Server sent an invalid subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket.protocol = serverProt;\n\n    if (perMessageDeflate) {\n      try {\n        const extensions = parse(res.headers['sec-websocket-extensions']);\n\n        if (extensions[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n          websocket._extensions[\n            PerMessageDeflate.extensionName\n          ] = perMessageDeflate;\n        }\n      } catch (err) {\n        abortHandshake(\n          websocket,\n          socket,\n          'Invalid Sec-WebSocket-Extensions header'\n        );\n        return;\n      }\n    }\n\n    websocket.setSocket(socket, head, opts.maxPayload);\n  });\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket)} stream The request to abort or the\n *     socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket.readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream.abort();\n    stream.once('abort', websocket.emitClose.bind(websocket));\n    websocket.emit('error', err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} data The data to send\n * @param {Function} cb Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    cb(err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {String} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n  websocket._socket.resume();\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  this[kWebSocket]._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  websocket._socket.removeListener('data', socketOnData);\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._closeCode = err[kStatusCode];\n  websocket.emit('error', err);\n  websocket._socket.destroy();\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {(String|Buffer|ArrayBuffer|Buffer[])} data The message\n * @private\n */\nfunction receiverOnMessage(data) {\n  this[kWebSocket].emit('message', data);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  websocket.pong(data, !websocket._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * The listener of the `net.Socket` `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('end', socketOnEnd);\n\n  websocket.readyState = WebSocket.CLOSING;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk and emitted synchronously in a single\n  // `'data'` event.\n  //\n  websocket._socket.read();\n  websocket._receiver.end();\n\n  this.removeListener('data', socketOnData);\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the `net.Socket` `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket.readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the `net.Socket` `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket.readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n","import * as vscode from 'vscode';\nimport { fileURLToPath } from 'url';\nimport * as path from 'path';\nimport * as fs from 'fs';\nimport * as ps from 'ps-node';\nimport * as child_process from 'child_process';\nimport { Channel, ChannelHandler } from '@storybook/channels';\nimport createChannel from \"@storybook/channel-websocket\"\n\nimport * as WebSocket from 'ws';\nimport { TreeViewProvider, StoryObject, Story } from \"./treeviewProvider\"\nimport { QuickPickProvider, StorySelection } from \"./quickpickProvider\"\n\nconst g = global as any;\ng.WebSocket = WebSocket;\nlet storybooksChannel: any;\nlet establishedConnection : boolean = false;\n\n/* EXPRESS SERVER & DEPENDENCY\n\nimport * as express from 'express';\nimport { resolveCliPathFromVSCodeExecutablePath } from 'vscode-test';\nconst server = express();\n\n*/\n/*\n\tclass AesopPanel implements vscode.WebviewPanel {\n\t\tviewType\n\t\ttitle: string = 'Aesop'\n\t\twebview: vscode.Webview = new AesopWebview\n\t\toptions: {retainContextWhenHidden: true}\n\t\tviewColumn: vscode.ViewColumn.Beside\n\t\tactive: boolean = true\n\t\tvisible: boolean = true\n\t\tonDidChangeViewState\n\t\tonDidDispose\n\t\treveal\n\t}\n\n\tclass AesopWebview implements vscode.Webview{\n\t\tasWebviewUri: any\n\t\tonDidReceiveMessage: any\n\t\tpostMessage: any\n\t\tcspSource: any\n\t\thtml: string =\n\t\t`<!DOCTYPE html>\n\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t\t\t\t<title>Aesop</title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t\t<iframe src=\"http://${host}:${PORT}/?path=/story/welcome--to-storybook></iframe>\n\t\t\t</body>\n\t\t</html>`\n\t\toptions: vscode.WebviewOptions = new AesopWVOptions\n\t}\n\n\tclass AesopWVOptions implements vscode.WebviewOptions{\n\t\tenableCommandUris: boolean = true\n\t\tenableScripts: boolean = true\n\t\tportMapping: [{\n\t\t\twebviewPort: number,\n\t\t\textensionHostPort: number\n\t\t}]\n\t}\n\nvscode.tasks.registerTaskProvider('runStorybook', {\n\tprovideTasks(token?: vscode.CancellationToken) {\n\t\t\treturn [\n\t\t\t\t\tnew vscode.Task({type: 'runStorybook'}, vscode.TaskScope.Workspace,\n\t\t\t\t\t\t\t\"Aesop Chronicle\", \"aesop\", new vscode.ShellExecution(`npm run storybook --ci`))\n\t\t\t];\n\t},\n\tresolveTask(task: vscode.Task, token?: vscode.CancellationToken) {\n\t\t\treturn task;\n\t}\n});\n\n//define the script text to execute to the virtual terminal instance\nconst bootScript = `storybook --ci`;\nconst bootStorybook = new vscode.ProcessExecution(bootScript, {cwd: rootDir});\n\n//now create a virtual terminal and execute our special npm script for it\n//this first requires creating an eventEmitter that will fire that script\nconst scriptEmitter = new vscode.EventEmitter<string>();\n\n//we also define a slave process Pseudoterminal (allowing Aesop to control the terminal)\nconst pty: vscode.Pseudoterminal = {\n\tonDidWrite: scriptEmitter.event,\n\topen: () =>\tscriptEmitter.fire(bootScript),\n\tclose: () => {},\n\thandleInput: data => new vscode.ShellExecution(data)\n};\n\n//should this just be an active terminal/shellExecution?\nconst virtualTerminal = vscode.window.createTerminal({name: 'sb-runner', pty});\n\n//THIS WORKS, but we have no access to the DOM inside our webview//\n//now let's read SB's outputted index.html file, and parse out what we need\n\tfs.readFile(path.join(rootDir, '/node_modules/@storybook/core/dist/public/index.html'), (err, data) => {\n\t\tif (err) console.error(err);\n\t\telse {\n\t\t\tlet pulledHTML = data.toString();\n\t\t\tlet targetPoint = pulledHTML.indexOf('</body>');\n\t\t\tlet firstHalf = pulledHTML.slice(0, targetPoint);\n\t\t\tlet secondHalf = pulledHTML.slice(targetPoint);\n\t\t\tpulledHTML = firstHalf.concat(payloadScript).concat(secondHalf);\n\t\t\tfs.writeFile(path.join(rootDir, '/node_modules/@storybook/core/dist/public/index.html'), pulledHTML, (err) => {\n\t\t\t\tif (err) console.error(err);\n\t\t\t\telse {\n\t\t\t\t\tvscode.window.showInformationMessage('Successfully injected script');\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t});\n\n//declare an empty array (of strings) to push our scripts to during the next part\n\tconst scriptArray : Array<string> = [];\n\t//define a path to the root working directory of the user\n\tconst rootDir = fileURLToPath(vscode.workspace.workspaceFolders[0].uri.toString(true));\n\t//now let's read SB's outputted index.html file, and parse out what we need\n\tfs.readFile(path.join(rootDir, '/node_modules/@storybook/core/dist/public/index.html'), (err, data) => {\n\t\tif (err) console.error(err);\n\t\telse {\n\t\t\t//if we've read the HTML file, take its contents and stringify it\n\t\t\tlet outputFile = data.toString();\n\t\t\t// this log shows what our eventual permutations would look like as we carve out the scripts\n\t\t\t// vscode.window.showWarningMessage(`what's in it: ${outputFile.slice(outputFile.indexOf('<body>')+6, outputFile.indexOf('</body>'))} \\n`)\n\t\t\t//split out the body section of the retrieved html file\n\t\t\toutputFile = outputFile.slice(outputFile.indexOf('<body>')+6, outputFile.indexOf('</body>'));\n\t\t\tvscode.window.showWarningMessage(`${outputFile} \\n`)\n\n\t\t\t//this loop will peel out all the scripts so long as there are any to rip out\n\t\t\twhile (outputFile.includes(`\"<script src=`)){\n\t\t\t\t//we push just what we need (the src attributes), leaving the <script>...</script> tags behind\n\t\t\t\tlet temp = outputFile.slice(outputFile.indexOf(`<script src=\"`)+12, outputFile.indexOf(`\"></script>`));\n\t\t\t\tscriptArray.push(temp);\n\t\t\t\toutputFile = outputFile.slice(outputFile.indexOf(`\"></script>`)+10);\n\t\t\t}\n\t\t};\n\t});\n\n<div id=\"root\"></div>\n<div id=\"docs-root\"></div>\t\n<div id=\"scriptExecute\">\n<script>window.acquireVsCodeApi = acquireVsCodeApi();</script>\n<script>window['DOCS_MODE'] = false;</script>\n<script>\n\t${\n\t\tscriptArray.map( (el) => {\n\t\t\tif (el.includes(\"./sb_dll\")){\n\t\t\t\tlet uiScript = document.createElement(\"script\");\n\t\t\t\tuiScript.async = true;\n\t\t\t\tuiScript.defer = true;\n\t\t\t\tuiScript.referrerPolicy = \"origin\";\n\t\t\t\tuiScript.src = path.join(rootDir, `/node_modules/@storybook/core/dll/${el}`);\n\t\t\t\tdocument.getElementById(\"scriptExecute\").appendChild(uiScript);\n\t\t\t}\telse {\n\t\t\t\tlet capturedScript = document.createElement(\"script\");\n\t\t\t\tcapturedScript.async = true;\n\t\t\t\tcapturedScript.defer = true;\n\t\t\t\tcapturedScript.referrerPolicy = \"origin\";\n\t\t\t\tcapturedScript.src = path.join(rootDir, `/node_modules/@storybook/core/dist/public/${el}`);\n\t\t\t\tdocument.getElementById(\"scriptExecute\").appendChild(capturedScript);\n\t\t\t}\n\t\t})\n\t}\n</script>\n</div>\n\ndisposable = vscode.commands.registerCommand('extension.getStories', () => {\n\tbuild a command that retrieves Storybook files on startup\n\tcan be executed later if Storybook server is spun up after the extension opens\n\t\n\talso register this command at startup to crawl the file path\n\t${vscode.commands.executeCommand('extension.getStories')}\n\tvscode.window.showInformationMessage('Aesop is reading from your Storybook.');\n\n\tdefine a path to SB webpack bundle outputs (in user workspace /node_modules/ folder)\n\tif (vscode.workspace.workspaceFolders[0] !== undefined){\n\t\tconst distGlob = new vscode.RelativePattern(vscode.workspace.workspaceFolders[0], \"**(remove)/node_modules/@storybook/core/dist/public\");\n\t\t//instantiate a watcher to listen for fs path changes (e.g. file creation/update)\n\t\t//bools = options for ignoreCreateEvents?, ignoreChangeEvents?, ignoreDeleteEvents?\t\n\t\tconst observer = vscode.workspace.createFileSystemWatcher(distGlob, false, false, false);\n\t\t// observer.onDidChange = //resolve//;\t\t// observer.onDidCreate = //resolve//;\n\t\t//extract index.html file that outputs into SB's preview pane\n\t\tconst htmlGlob = new vscode.RelativePattern(vscode.workspace.workspaceFolders[0], \"*(remove)/node_modules/@storybook/core/dist/public/*.html\");\n\t\t//extract necessary bundle scripts to leverage in-app dependencies\n\t\tconst scriptGlob = new vscode.RelativePattern(vscode.workspace.workspaceFolders[0], \"*(remove)/node_modules/@storybook/core/dist/public/*.js\");\n\n\t\tconsole.log(vscode.Uri.file(fileURLToPath(`/node_modules/@storybook/core/dist/public`)));\n\n\t\t//do we need to resolve the Storybook UI script from the /dll/ folder?\n\t\t//if extract methods above fail, determine logic to parse out HTML/.js scripts (index 0?);\n\t\t//retrieve files with findFiles/relativeFilePath\n\t\tconst arrayOfScripts = vscode.workspace.findFiles(distGlob, null, 100);\n\t\t//dev check: have we successfully pulled down script files?\n\t\t//if so, should we then store them locally, or is there no point?\n\t\tif (arrayOfScripts !== undefined){\n\t\t\tvscode.window.showInformationMessage(\"Hey, dog: \" + `${arrayOfScripts}`);\n\t\t}\n\n\t\tvscode.window.showInformationMessage(`\n\t\trootPath: ${vscode.workspace.workspaceFolders[0]},\n\t\tvscode.Uri: ${vscode.Uri},\n\t\tworkspace: ${vscode.workspace},\n\t\tdistGlob: ${distGlob.toString()},\n\t\thtmlGlob: ${htmlGlob.toString()},\n\t\tscriptGlob: ${scriptGlob.toString()}\n\t\t`);\n\t};\n\n\tvscode.window.showInformationMessage(`\n\t\trootPath: ${vscode.workspace.workspaceFolders[0].uri.toString()},\\n\n\t\tvscode URI parseTest: ${vscode.Uri.parse('file://'+ '/node_modules/@storybook/core/dist/public/index.html')},\\n\n\t\tvscode URI parsed w escape: ${vscode.Uri.parse('file://'+ '/node_modules/\\@storybook/core/dist/public/index.html')},\\n\n\t\tvscode URI  file Test: ${vscode.Uri.file('node_modules/@storybook/core/dist/public/index.html')}\n\t\t`);\n\t\t\n\tconsole.log(`\n\trootPath: ${vscode.workspace.workspaceFolders[0]},\n\tvscode.Uri: ${vscode.Uri},\n\tworkspace: ${vscode.workspace},\n\tfileSys: ${vscode.Uri.file(path.join('/'))}`);\n});\n\nvscode.tasks.registerTaskProvider('runStorybook', {\n\tprovideTasks(token?: vscode.CancellationToken) {\n\t\t\treturn [\n\t\t\t\t\tnew vscode.Task({type: 'runStorybook'}, vscode.TaskScope.Workspace,\n\t\t\t\t\t\t\t\"Aesop Chronicle\", \"aesop\", new vscode.ShellExecution(`npm run storybook --ci`))\n\t\t\t];\n\t},\n\tresolveTask(task: vscode.Task, token?: vscode.CancellationToken) {\n\t\t\treturn task;\n\t}\n});\n\n//define the script text to execute to the virtual terminal instance\nconst bootScript = `storybook --ci`;\nconst bootStorybook = new vscode.ProcessExecution(bootScript, {cwd: rootDir});\n\n//now create a virtual terminal and execute our special npm script for it\n//this first requires creating an eventEmitter that will fire that script\nconst scriptEmitter = new vscode.EventEmitter<string>();\n\n//we also define a slave process Pseudoterminal (allowing Aesop to control the terminal)\nconst pty: vscode.Pseudoterminal = {\n\tonDidWrite: scriptEmitter.event,\n\topen: () =>\tscriptEmitter.fire(bootScript),\n\tclose: () => {},\n\thandleInput: data => new vscode.ShellExecution(data)\n};\n\n//should this just be an active terminal/shellExecution?\nconst virtualTerminal = vscode.window.createTerminal({name: 'sb-runner', pty});\n*/\n/* ALTERNATE APPROACH W/O PS-NODE LIBRARY\n\n\texport async function isProcessRunning(processName: string): Promise<boolean> {\n\tconst cmd = (() => {\n\t\tswitch (process.platform) {\n\t\t\tcase 'win32': return `tasklist`\n\t\t\tcase 'darwin': return `ps -ax | grep ${processName}`\n\t\t\tcase 'linux': return `ps -A`\n\t\t\tdefault: return false\n\t\t}\n\t})()\n\n\treturn new Promise((resolve, reject) => {\n\t\trequire('child_process').exec(cmd, (err: Error, stdout: string, stderr: string) => {\n\t\t\tif (err) reject(err)\n\n\t\t\tresolve(stdout.toLowerCase().indexOf(processName.toLowerCase()) > -1)\n\t\t})\n\t})\n}\nconst running: boolean = await isProcessRunning('myProcess')\n\n*/\n/* EXPRESS SERVER\n\n\tserver.get('/', (req, res) => {\n\t\tvscode.window.showInformationMessage('Aesop server online');\n\t\tres.end();\n\t});\n\tserver.listen(PORT);\n\n*/\n\t/*\n\t//we need this to interface with/emit events to the storybook-channels websocket library\n\tlet previewUri = vscode.Uri.parse(\"storybook://authority/preview\")\n\n\tclass WebviewHTMLProvider implements vscode.TextDocumentContentProvider {\n\t\tpublic provideTextDocumentContent(uri: vscode.Uri): string {\n\t\t\t//do we need to pass these arguments to the webviewprovider from our processes?\n\t\t\t//https://code.visualstudio.com/api/references/vscode-api#WorkspaceConfiguration\n\t\t\t//UPDATE configuration when found\n\n\t\t\t//'PORT' and 'host' have defaults configured manually in the package.json\n\t\t\tconst port = vscode.workspace.getConfiguration(\"aesop\").get(\"port\")\n\t\t\tconst host = vscode.workspace.getConfiguration(\"aesop\").get(\"host\")\n\n\t\t\t//this return value is what would normally get popped into the preview --> /?path=/story/${storyUri}\n\t\t\treturn `\n\t\t\t<!DOCTYPE html>\n\t\t\t<html lang=\"en\">\n\t\t\t\t<head>\n\t\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t\t\t\t\t<title>Aesop</title>\n\t\t\t\t\t<style>\n\t\t\t\t\tiframe {\n\t\t\t\t\t\tposition: fixed;\n\t\t\t\t\t\tborder: none;\n\t\t\t\t\t\tpadding: 0;\n\t\t\t\t\t\tmargins: 0;\n\t\t\t\t\t\twidth: 100%;\n\t\t\t\t\t\theight: 100%;\n\t\t\t\t\t}\n\t\t\t\t</style>\n\t\t\t\t</head>\n\t\t\t\t<body>\n\t\t\t\t\t<iframe src=\"http://${host}:${port}></iframe>\n\t\t\t\t</body>\n\t\t\t</html>`\n\t\t}\n\t}\n\n\tlet provider = new WebviewHTMLProvider();\n\tlet webviewHTMLRegistration = vscode.workspace.registerTextDocumentContentProvider(\"storybook\", provider);\n\n\t//\"storybook\" is the scheme here; where is that defined? contributes?\n\tconst storyTreeViewProvider = new TreeViewProvider();\n\tvscode.window.registerTreeDataProvider(\"storybook\", storyTreeViewProvider);\n\tconst pickerProvider = new QuickPickProvider(storyTreeViewProvider);\n\n\tlet previewDisposable = vscode.commands.registerCommand(\"extension.showStorybookPreview\", () => {\n\t\t//maybe we can use a blank webview and REASSIGN its html each time with a boilerplate HTML file and an iframe spot for the html fired at previewHtml here\n\n\t\treturn vscode.commands.executeCommand(\"vscode.previewHtml\", previewUri, vscode.ViewColumn.Two, \"Storybooks\").then(\n      success => {},\n      //should really (by convention) use a .catch() method for the error (call it \"error\", not \"reason\")\n      reason => {\n        vscode.window.showErrorMessage(reason)\n      }\n    )\n\t})\n\n\tcontext.subscriptions.push(previewDisposable, webviewHTMLRegistration);\n\n\tstorybooksChannel = createChannel({ url: `ws://${host}:${port}`, async: true, onError: () => {} })\n\n  //declares variables with no initial value, reassigns at each request\n  var currentKind: string = null\n  var currentStory: string = null\n  var currentStoryId: string = null\n\n  // Create a statusbar item to reconnect, when we lose connection\n  const reconnectStatusBarItem = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left)\n  reconnectStatusBarItem.command = \"extension.restartConnectionToStorybooks\"\n  if (establishedConnection) {\n    reconnectStatusBarItem.text = \"Reconnect Storybooks\"\n    reconnectStatusBarItem.color = \"#FF8989\"\n  } else {\n    reconnectStatusBarItem.text = \"Connect to Storybooks\"\n  }\n\n  reconnectStatusBarItem.hide()\n\n  // when we (re-)connect to Storybook's server, pass the WS connection to this func, so callbacks can occur on new socket connection\n\n  const registerCallbacks = channel => {\n\n    // Called when we first get stories from the Storybook server\n    // may have to add logic that executes a getStories command after the webview has been served up by the primary Aesop Awaken function\n    //setStories is a method defined on the websocket connection\n\n    channel.on(\"setStories\", data => {\n      //this configuration exists in package.json, and defines a filter that is initialised to a \".\"\n      //this is probably configurable in the extension settings, something we still have to tackle\n      //we should also think about the store presentation, logo, Readme...\n\n      //TO FOLLOW UP: why use this filter? what is it reading? the DOM on the server?\n\n      const filter = vscode.workspace.getConfiguration(\"react-native-storybooks\").get(\"storybookFilterRegex\") as string\n      const regex = new RegExp(filter)\n\n      //use Story interface to init this variable (id: string, name: string)\n      let stories: Story[] = []\n\n      //gets the data returned from the socket when calling setStories, we see if the data has a property \"stories\" which contains an Array of usable elements\n\n      if (Array.isArray(data.stories)) {\n        //if the data contains a stories property that is an Array\n        //declare a variable kinds that:\n        //inits to an empty Object but takes a type assertion of:\n        //Object -> [key]: value = array of Story Objects\n        \n        let kinds: { [key: string]: StoryObject[] } = {}\n        //this is basically asking if the stories returned from the data have a \"kind\" property, and if the kind contains a period\n        const storydata = data.stories.filter(s => s.kind.match(regex))\n\n        storydata.map(story => {\n          story.stories.map(singleStory => {\n            if (kinds[story.kind] == undefined) {\n              // kinds[story.kind] = [story.name]\n              kinds[story.kind] = [{ name: singleStory, id: singleStory }]\n            } else {\n              kinds[story.kind].push({ name: singleStory, id: singleStory })\n            }\n          })\n        })\n        Object.keys(kinds).forEach(function(key) {\n          stories.push({\n            kind: key,\n            stories: kinds[key]\n          })\n        })\n      } else {\n        let kinds: { [key: string]: StoryObject[] } = {}\n        Object.keys(data.stories).forEach(function(key) {\n          const story = data.stories[key]\n          if (story.kind.match(regex)) {\n            if (kinds[story.kind] == undefined) {\n              // kinds[story.kind] = [story.name]\n              kinds[story.kind] = [{ name: story.name, id: story.id }]\n            } else {\n              kinds[story.kind].push({ name: story.name, id: story.id })\n            }\n          }\n        })\n        Object.keys(kinds).forEach(function(key) {\n          stories.push({\n            kind: key,\n            stories: kinds[key]\n          })\n        })\n      }\n      storyTreeViewProvider.stories = stories\n      storyTreeViewProvider.refresh()\n      reconnectStatusBarItem.hide()\n    })\n\n    // When the server in RN starts up, it asks what should be default\n    channel.on(\"getCurrentStory\", () => {\n      storybooksChannel.emit(\"setCurrentStory\", {\n        storyId: currentStoryId\n      })\n    })\n\n    // The React Native server has closed\n    channel.transport.socket.onclose = () => {\n      storyTreeViewProvider.stories = []\n      storyTreeViewProvider.refresh()\n      reconnectStatusBarItem.show()\n    }\n\n    channel.emit(\"getStories\")\n  }\n\n  registerCallbacks(storybooksChannel)\n\n  vscode.commands.registerCommand(\"extension.searchStories\", () => {\n    vscode.window.showQuickPick(pickerProvider.toList()).then((picked: string) => {\n      const setParams = pickerProvider.getParts(picked)\n      setCurrentStory(setParams)\n    })\n  })\n\n  // Allow clicking, and keep state on what is selected\n  vscode.commands.registerCommand(\"extension.openStory\", (section, story) => {\n    // Handle a Double click\n    if (currentStoryId === story.id && currentKind === section.kind && currentStory === story.name) {\n      findFileForStory(section.kind, story.name).then(results => {\n        if (results) {\n          vscode.workspace.openTextDocument(results.uri).then(doc => {\n            vscode.window.showTextDocument(doc).then(shownDoc => {\n              let range = doc.lineAt(results.line - 1).range\n              vscode.window.activeTextEditor.selection = new vscode.Selection(range.start, range.end)\n              vscode.window.activeTextEditor.revealRange(range, vscode.TextEditorRevealType.InCenter)\n            })\n          })\n        }\n      })\n      return\n    }\n\n    setCurrentStory({ storyId: story.id, kind: section.kind, story: story.name })\n  })\n\n  function setCurrentStory(params: StorySelection) {\n    const currentChannel = () => storybooksChannel\n    currentKind = params.kind\n    currentStory = params.story\n    currentStoryId = params.storyId\n    currentChannel().emit(\"setCurrentStory\", params)\n  }\n\n  //when connecting to storybook, create a websocket connection\n  //then pass it as an argument to the registerCallbacks function\n  vscode.commands.registerCommand(\"extension.connectToStorybooks\", () => {\n    storybooksChannel = createChannel({ url: `ws://${host}:${port}`, async: true, onError: () => {} })\n    registerCallbacks(storybooksChannel)\n  })\n\n  vscode.commands.registerCommand(\"extension.restartConnectionToStorybooks\", () => {\n    storybooksChannel = createChannel({ url: `ws://${host}:${port}`, async: true, onError: () => {} })\n    registerCallbacks(storybooksChannel)\n  })\n\n  vscode.commands.registerCommand(\"extension.goToNextStorybook\", () => {\n    const stories = storyTreeViewProvider.stories\n    const currentSection = stories.find(s => s.kind === currentKind)\n    const currentStories = currentSection.stories\n    const currentIndex = currentStories.map(e => e.id).indexOf(currentStoryId)\n    if (currentIndex === currentStories.length) {\n      // if you have reached the last story of an array of stories, enables the ability to wrap around\n      vscode.commands.executeCommand(\"extension.openStory\", currentSection, currentStories[0])\n    } else {\n\n      vscode.commands.executeCommand(\"extension.openStory\", currentSection, currentStories[currentIndex + 1])\n    }\n  })\n\n  vscode.commands.registerCommand(\"extension.goToPreviousStorybook\", () => {\n    const stories = storyTreeViewProvider.stories\n    const currentSection = stories.find(s => s.kind === currentKind)\n    const currentStories = currentSection.stories\n    const currentIndex = currentStories.map(e => e.id).indexOf(currentStoryId)\n    if (currentIndex === 0) {\n      // if you have reached the last story of an array of stories, enables the ability to wrap around\n      vscode.commands.executeCommand(\"extension.openStory\", currentSection, currentStories[currentStories.length - 1])\n    } else {\n      vscode.commands.executeCommand(\"extension.openStory\", currentSection, currentStories[currentIndex - 1])\n    }\n  })\n\n  vscode.commands.registerCommand(\"extension.expandAllStories\", () => {\n    storyTreeViewProvider.expandAll()\n  })\n\n  vscode.commands.registerCommand(\"extension.collapseAllStories\", () => {\n    storyTreeViewProvider.collapseAll()\n  })\n}\n*/\n// Loop through all globbed stories,\n// reading the files for the kind and the story name\n// const findFileForStory = async (kind: string, story: string): Promise<{ uri: vscode.Uri; line: number } | null> => {\n//   return new Promise<{ uri: vscode.Uri; line: number }>((resolve, reject) => {\n//     //this regex is set as a glob expression in package.json that finds **.story.* files\n//     const regex = vscode.workspace.getConfiguration(\"react-native-storybooks\").get(\"storyRegex\") as string\n\n//     const root = vscode.workspace.workspaceFolders\n//     vscode.workspace.findFiles(regex, \"**/node_modules\").then(files => {\n//       let found = false\n//       for (const file of files) {\n//         const content = fs.readFileSync(file.fsPath, \"utf8\")\n//         if (content.includes(kind) && content.includes(story)) {\n//           const line = content.split(story)[0].split(\"\\n\").length\n//           resolve({ uri: file, line })\n//           found = true\n//         }\n//       }\n//       if (!found) {\n//         resolve(null)\n//       }\n//     })\n//   })\n// }\n\nexport function activate(context: vscode.ExtensionContext) {\n\n\tlet port : number = vscode.workspace.getConfiguration(\"aesop\").get(\"port\");\n\tlet host : string = vscode.workspace.getConfiguration(\"aesop\").get(\"host\");\n\n\tvscode.window.showInformationMessage(`Port default to ${port}`);\n\n\t//set context \"aesop-awake\" to true; enabling views\n\tvscode.commands.executeCommand(\"setContext\", \"aesop-awake\", true);\n\n\t//create disposable to register Aesop Awaken command to subscriptions\n\tlet disposable = vscode.commands.registerCommand('extension.aesopAwaken', () => {\n\n\t\t//declare variable to toggle whether running Node processes have been checked\n\t\tlet checkedProcesses : Boolean = false;\n\n\t\t//declare variable to toggle whether a running SB process was found\n\t\tlet foundSb : Boolean = false;\n\n\t\t//define a path to the user's root working directory\n\t\tconst rootDir = fileURLToPath(vscode.workspace.workspaceFolders[0].uri.toString(true));\n\n\t\t//first test whether Storybook has been depended into your application\n\t\tfs.access(path.join(rootDir, '/node_modules/@storybook'), (err) => {\n\n\t\t\tconst statusText = vscode.window.createStatusBarItem(vscode.StatusBarAlignment.Left);\n\t\t\tstatusText.text = \"[Aesop] Looking for Storybook dependency...\"\n\t\t\tstatusText.color = \"#FF8989\";\t\n\n\t\t\t//if the filepath isn't found, show the user what Aesop is reading as the root path\n\t\t\tif (err) {\n\t\t\t\tvscode.window.showErrorMessage(`Aesop could not find Storybook as a dependency in the active folder, ${rootDir}`);\n\t\t\t\tstatusText.dispose();\n\t\t\t}\telse {\n\t\t\t\t//check to see if a storybook node process is already running\n\t\t\t\tif (checkedProcesses === false){\n\t\t\t\t\t\n\t\t\t\t\tps.lookup({command: 'node', psargs: 'ux'}, (err, resultList) => {\n\t\t\t\t\t\tif (err){\n\t\t\t\t\t\t\tvscode.window.showErrorMessage(`Failed looking for running Node processes. Error: ${err}`);\n\t\t\t\t\t\t\tstatusText.dispose();\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t//notify the user that Aesop is checking for a running Storybook instance\n\t\t\t\t\t\t\tstatusText.text = `[Aesop] Reviewing running processes...`;\n\n\t\t\t\t\t\t\t//if the process lookup was able to find running processes, iterate through to review them\n\t\t\t\t\t\t\tresultList.forEach((process) => {\n\n\t\t\t\t\t\t\t\t/* OUTPUT LOGGER */\n\t\t\t\t\t\t\t\tfs.writeFile(path.join(rootDir, 'YOLO.txt'), `Attempted launch log:\\n`,\n\t\t\t\t\t\t\t\t(err) => {console.log(`Couldn't output process information to YOLO.txt: ${err}`)});\n\t\t\n\t\t\t\t\t\t\t\t//check if any running processes are Storybook processes\n\t\t\t\t\t\t\t\tif(process.arguments[0].includes('storybook')){\n\n\t\t\t\t\t\t\t\t\t//stretch goal: check for multiple instances of storybook and reconcile\n\t\t\t\t\t\t\t\t\t//if so, extract port number and use that value to populate the webview with that contents\n\t\t\t\t\t\t\t\t\tconst pFlagIndex = process.arguments.indexOf('-p');\n\t\t\t\t\t\t\t\t\tif (pFlagIndex !== -1){\n\t\t\t\t\t\t\t\t\t\tport = parseInt(process.arguments[pFlagIndex+1]);\n\t\t\t\t\t\t\t\t\t}\n\t\t\n\t\t\t\t\t\t\t\t\t/* OUTPUT LOGGER */\n\t\t\t\t\t\t\t\t\tfs.appendFile(path.join(rootDir, 'YOLO.txt'), `This process matches for 'storybook':\\n\n\t\t\t\t\t\t\t\t\tPID: ${process.pid}, COMMAND:${process.command}, ARGUMENTS: ${process.arguments}\\n\n\t\t\t\t\t\t\t\t\tPORT has been assigned to: ${port}`, (err) => {console.log(err)});\n\n\t\t\t\t\t\t\t\t\t//set foundSb to true to prevent our function from running another process\n\t\t\t\t\t\t\t\t\tfoundSb = true;\n\t\t\t\t\t\t\t\t\tstatusText.text = `[Aesop] Retrieving your running Storybook...`;\n\n\t\t\t\t\t\t\t\t}//---> close if process.arguments[0] contains storybook\n\t\t\t\t\t\t\t}) //---> close resultList.forEach()\n\n\t\t\t\t\t\t\t//having checked running Node processes, set that variable to true\n\t\t\t\t\t\t\tcheckedProcesses = true;\n\t\t\t\t\t\t\n\t\t\t\t\t\t\t//if no processes matched 'storybook', we will have to spin up the storybook server\n\t\t\t\t\t\t\tif (checkedProcesses === true && foundSb === false){\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t//starts by checking for/extracting any port flages from the SB script in the package.json\n\t\t\t\t\t\t\t\tfs.readFile(path.join(rootDir, 'package.json'), (err, data) => {\n\t\t\t\t\t\t\t\t\tif (err){\n\t\t\t\t\t\t\t\t\t\tvscode.window.showErrorMessage(`Aesop is attempting to read ${rootDir}. Is there a package.json file here?`);\n\t\t\t\t\t\t\t\t\t}\telse {\n\t\t\t\t\t\t\t\t\t\tstatusText.text = `[Aesop] Checking your Storybook scripts in package.json...`;\n\n\t\t\t\t\t\t\t\t\t\t//enter the package.JSON file and retrieve its contents as an object\n\t\t\t\t\t\t\t\t\t\tlet packageJSON = JSON.parse(data.toString());\n\t\t\t\t\t\t\t\t\t\tlet storybookScript = packageJSON.scripts.storybook;\n\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t/* OUTPUT LOGGER */\n\t\t\t\t\t\t\t\t\t\tfs.appendFile(path.join(rootDir, 'YOLO.txt'), `Here is the script for \"storybook\":\\n\n\t\t\t\t\t\t\t\t\t\t${storybookScript}`, (err) => {console.log(err)});\n\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t//iterate through the text string (stored on \"storybook\" key) and parse out port flag\n\t\t\t\t\t\t\t\t\t\t//it is more helpful to split it into an array separated by whitespace to grab this\n\t\t\t\t\t\t\t\t\t\tlet retrievedScriptArray = storybookScript.split(' ');\n\t\t\t\t\t\t\t\t\t\tfor (let i = 0; i < retrievedScriptArray.length; i++){\n\t\t\t\t\t\t\t\t\t\t\t//stretch goal: add logic for other flags as we implement further functionality\n\t\t\t\t\t\t\t\t\t\t\tif (retrievedScriptArray[i] === '-p'){\n\t\t\t\t\t\t\t\t\t\t\t\tport = parseInt(retrievedScriptArray[i+1]);\n\n\t\t\t\t\t\t\t\t\t\t\t\t/* OUTPUT LOGGER */\n\t\t\t\t\t\t\t\t\t\t\t\tfs.appendFile(path.join(rootDir, 'YOLO.txt'), `Port from script\":\\n${parseInt(retrievedScriptArray[i+1])}\\n\n\t\t\t\t\t\t\t\t\t\t\t\tPort at this moment:\\n${port}\\n`, (err) => {console.log(err)});\n\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t} else if (i === retrievedScriptArray.length-1){\n\t\t\t\t\t\t\t\t\t\t\t\t//termination case: when you have reached the end of the script in the 'for' loop\n\t\t\t\t\t\t\t\t\t\t\t\t//ADD LOGIC TO HANDLE WHEN NO SCRIPT FLAG IS GIVEN\n\n\t\t\t\t\t\t\t\t\t\t\t\t/* OUTPUT LOGGER */\n\t\t\t\t\t\t\t\t\t\t\t\tfs.appendFile(path.join(rootDir, 'YOLO.txt'), `Script found, but no port flag detected.\\n\n\t\t\t\t\t\t\t\t\t\t\t\tPort when no port flag found:\\n${port}\\n`, (err) => {console.log(err)});\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t//possible: add --ci tag to existing package.json with an fs function?\n\t\t\t\t\t\t\t\t\t\t//e.g. process.scripts.storybook = `${storybookScript} --ci`, then write\n\n\t\t\t\t\t\t\t\t\t\t//now launch the child process on the port you've derived\n\t\t\t\t\t\t\t\t\t\tconst runSb = child_process.spawn('npm', ['run', 'storybook']);\n\n\t\t\t\t\t\t\t\t\t\tvscode.window.showInformationMessage(\"Done looking. Aesop will now run Storybook for you.\");\n\n\t\t\t\t\t\t\t\t\t\trunSb.stdout.setEncoding('utf8');\n\n\t\t\t\t\t\t\t\t\t\tlet counter = 0;\n\n\t\t\t\t\t\t\t\t\t\trunSb.stdout.on('data', (data) => {\n\t\t\t\t\t\t\t\t\t\t\tlet str = data.toString();\n\t\t\t\t\t\t\t\t\t\t\tlet lines = str.split(\" \");\n\t\t\t\t\t\t\t\t\t\t\tcounter += 1;\n\n\t\t\t\t\t\t\t\t\t\t\tif (counter === 3) {\n\t\t\t\t\t\t\t\t\t\t\t\tconst path = lines[171];\n\t\t\t\t\t\t\t\t\t\t\t\tconst regExp = (/[^0-9]/g);\n\t\t\t\t\t\t\t\t\t\t\t\tport = parseInt(path.replace(regExp, \"\"));\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\tlet sbPortFlag = '-p';\n\t\t\t\t\t\t\t\t\t\t\t  if (lines.includes(sbPortFlag)){\n\t\t\t\t\t\t\t\t\t\t\t    const indexOfP = lines.indexOf(sbPortFlag);\n\t\t\t\t\t\t\t\t\t\t\t    vscode.window.showInformationMessage(`This is indexOfP: `, indexOfP);\n\t\t\t\t\t\t\t\t\t\t\t    if(indexOfP !== -1) {\n\t\t\t\t\t\t\t\t\t\t\t      port = parseInt(lines[indexOfP + 1]);\n\t\t\t\t\t\t\t\t\t\t\t      vscode.window.showInformationMessage(`storybook is now running on port: ${port}`);\n\t\t\t\t\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t\t\t\trunSb.on('error', (err) => {\n\t\t\t\t\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\t\t\t\t\tprocess.exit(1);\n\t\t\t\t\t\t\t\t\t\t})\n\n\t\t\t\t\t\t\t\t\t\t//This will make sure the child process is terminated on process exit\n\t\t\t\t\t\t\t\t\t\trunSb.on('close', (code) => {\n\t\t\t\t\t\t\t\t\t\t\tconsole.log(`child process exited with code ${code}`);\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t} //close spin up server\n\t\t\t\t\t\t}; //CLOSE else psLookup\n\t\t\t\t\t}); //close ps LOOKUP\n\t\t\t\t} //close depend found, not checked processes\n\t\t\t}//close else statement in fs.access\n\t\t}) //close fs access\n\t}); //close disposable\n\n\tcontext.subscriptions.push(disposable);\n\n\tlet openDisposable = vscode.commands.registerCommand('extension.aesopChronicle', () => {\n\t\tconst panel = vscode.window.createWebviewPanel(\n\t\t\t'aesop-sb',\n\t\t\t'Aesop',\n\t\t\tvscode.ViewColumn.Beside,\n\t\t\t{\n\t\t\t\tenableScripts: true,\n\t\t\t\tlocalResourceRoots: [vscode.Uri.file(context.extensionPath)]\n\t\t\t}\n\t\t);\n\t\n\t\t//here's where I need logic to fill html\n\t\tpanel.webview.html = `\n\t\t<!DOCTYPE html>\n\t\t<html lang=\"en\">\n\t\t\t<head>\n\t\t\t\t<meta charset=\"UTF-8\">\n\t\t\t\t<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n\t\t\t\t<title>Aesop</title>\n\t\t\t</head>\n\t\t\t<body>\n\t\t\t\t<iframe src=\"http://${host}:${port}/?path=/story/welcome--to-storybook></iframe>\n\t\t\t</body>\n\t\t</html>`\n\t});\n\n\tcontext.subscriptions.push(openDisposable);\n}\n\nexport function deactivate() {\n\t// storybooksChannel.transport.socket.close()\n}\n","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"stream\");","module.exports = require(\"tls\");","module.exports = require(\"url\");","module.exports = require(\"vscode\");","module.exports = require(\"zlib\");"],"sourceRoot":""}